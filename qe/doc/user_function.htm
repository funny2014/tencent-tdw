<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="zh-cn" dir="ltr">
<head>
<title>TDW 函数在线手册 - TDW WIKI</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="MediaWiki 1.16.2" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="TDW WIKI (zh-cn)" />
<link rel="alternate" type="application/atom+xml" title="TDW WIKI的Atom订阅" href="/wiki/index.php?title=%E7%89%B9%E6%AE%8A:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9&amp;feed=atom" />
<link rel="stylesheet" href="/wiki/skins/common/shared.css?270" media="screen" />
<link rel="stylesheet" href="/wiki/skins/common/commonPrint.css?270" media="print" />
<link rel="stylesheet" href="/wiki/skins/monobook/main.css?270" media="screen" />
<!--[if lt IE 5.5000]><link rel="stylesheet" href="/wiki/skins/monobook/IE50Fixes.css?270" media="screen" /><![endif]-->
<!--[if IE 5.5000]><link rel="stylesheet" href="/wiki/skins/monobook/IE55Fixes.css?270" media="screen" /><![endif]-->
<!--[if IE 6]><link rel="stylesheet" href="/wiki/skins/monobook/IE60Fixes.css?270" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/wiki/skins/monobook/IE70Fixes.css?270" media="screen" /><![endif]-->
<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" />
<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" media="print" />
<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" />
<link rel="stylesheet" href="/wiki/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" />
<script>
var skin="monobook",
stylepath="/wiki/skins",
wgUrlProtocols="http\\:\\/\\/|https\\:\\/\\/|ftp\\:\\/\\/|irc\\:\\/\\/|gopher\\:\\/\\/|telnet\\:\\/\\/|nntp\\:\\/\\/|worldwind\\:\\/\\/|mailto\\:|news\\:|svn\\:\\/\\/",
wgArticlePath="/wiki/index.php/$1",
wgScriptPath="/wiki",
wgScriptExtension=".php",
wgScript="/wiki/index.php",
wgVariantArticlePath=false,
wgActionPaths={},
wgServer="http://tdw.boss.com",
wgCanonicalNamespace="",
wgCanonicalSpecialPageName=false,
wgNamespaceNumber=0,
wgPageName="TDW_函数在线手册",
wgTitle="TDW 函数在线手册",
wgAction="view",
wgArticleId=33,
wgIsArticle=true,
wgUserName=null,
wgUserGroups=null,
wgUserLanguage="zh-cn",
wgContentLanguage="zh-cn",
wgBreakFrames=false,
wgCurRevisionId=3434,
wgVersion="1.16.2",
wgEnableAPI=true,
wgEnableWriteAPI=true,
wgSeparatorTransformTable=["", ""],
wgDigitTransformTable=["", ""],
wgMainPageTitle="首页",
wgFormattedNamespaces={"-2": "媒体", "-1": "特殊", "0": "", "1": "讨论", "2": "用户", "3": "用户讨论", "4": "TDW WIKI", "5": "TDW WIKI讨论", "6": "文件", "7": "文件讨论", "8": "MediaWiki", "9": "MediaWiki讨论", "10": "模板", "11": "模板讨论", "12": "帮助", "13": "帮助讨论", "14": "分类", "15": "分类讨论"},
wgNamespaceIds={"媒体": -2, "特殊": -1, "": 0, "讨论": 1, "用户": 2, "用户讨论": 3, "tdw_wiki": 4, "tdw_wiki讨论": 5, "文件": 6, "文件讨论": 7, "mediawiki": 8, "mediawiki讨论": 9, "模板": 10, "模板讨论": 11, "帮助": 12, "帮助讨论": 13, "分类": 14, "分类讨论": 15, "对话": 1, "用户对话": 3, "图像": 6, "档案": 6, "image": 6, "image_talk": 7, "图像对话": 7, "图像讨论": 7, "档案对话": 7, "档案讨论": 7, "文件对话": 7, "模板对话": 11, "帮助对话": 13, "分类对话": 15},
wgSiteName="TDW WIKI",
wgCategories=[],
wgRestrictionEdit=[],
wgRestrictionMove=[],
wgFCKEditorDir="extensions/WYSIWYG/ckeditor/",
wgFCKEditorExtDir="extensions/WYSIWYG",
wgFCKEditorToolbarSet="Wiki",
wgFCKEditorHeight="0",
wgCKeditorMagicWords={"wikitags": ["nowiki", "includeonly", "onlyinclude", "noinclude", "pre", "gallery", "source", "syntaxhighlight"], "magicwords": ["NOTOC", "FORCETOC", "TOC", "NOEDITSECTION", "NEWSECTIONLINK", "NONEWSECTIONLINK", "NOCONTENTCONVERT", "NOCC", "NOTITLECONVERT", "NOTC", "NOGALLERY", "INDEX", "NOINDEX", "STATICREDIRECT", "NOGALLERY", "HIDDENCAT", "START", "END"], "datevars": ["CURRENTYEAR", "CURRENTMONTH", "CURRENTMONTHNAME", "CURRENTMONTHNAMEGEN", "CURRENTMONTHABBREV", "CURRENTDAY", "CURRENTDAY2", "CURRENTDOW", "CURRENTDAYNAME", "CURRENTTIME", "CURRENTHOUR", "CURRENTWEEK", "CURRENTTIMESTAMP"], "wikivars": ["SITENAME", "SERVER", "SERVERNAME", "DIRMARK", "SCRIPTPATH", "CURRENTVERSION", "CONTENTLANG", "REVISIONID", "REVISIONDAY", "REVISIONDAY2", "REVISIONMONTH", "REVISIONYEAR", "REVISIONTIMESTAMP", "REVISIONUSER", "FULLPAGENAME", "PAGENAME", "BASEPAGENAME", "SUBPAGENAME", "SUBJECTPAGENAME", "TALKPAGENAME", "NAMESPACE", "ARTICLESPACE", "TALKSPACE"], "parserhooks": ["lc", "lcfirst", "uc", "ucfirst", "formatnum", "#dateformat", "padleft", "padright", "plural", "grammar", "#language", "int", "#tag", "#int", "#ns", "#nse", "#urlencode", "#lcfirst", "#ucfirst", "#lc", "#uc", "#localurl", "#localurle", "#fullurl", "#fullurle", "#formatnum", "#grammar", "#gender", "#plural", "#numberofpages", "#numberofusers", "#numberofactiveusers", "#numberofarticles", "#numberoffiles", "#numberofadmins", "#numberingroup", "#numberofedits", "#numberofviews", "#padleft", "#padright", "#anchorencode", "#special", "#defaultsort", "#filepath", "#pagesincategory", "#pagesize", "#protectionlevel", "#namespace", "#namespacee", "#talkspace", "#talkspacee", "#subjectspace", "#subjectspacee", "#pagename", "#pagenamee", "#fullpagename", "#fullpagenamee", "#basepagename", "#basepagenamee", "#subpagename", "#subpagenamee", "#talkpagename", "#talkpagenamee", "#subjectpagename", "#subjectpagenamee", "#formatdate", "#displaytitle"]},
wgCKeditorUseBuildin4Extensions=[],
wgAllowExternalImages=true;
</script><script src="/wiki/skins/common/wikibits.js?270"></script>
<script src="/wiki/skins/common/ajax.js?270"></script>
<script src="/wiki/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook&amp;270"></script>

</head>
<body class="mediawiki ltr ns-0 ns-subject page-TDW_函数在线手册 skin-monobook">
<div id="globalWrapper">
<div id="column-content"><div id="content" >
	<a id="top"></a>
	
	<h1 id="firstHeading" class="firstHeading">TDW 函数在线手册</h1>
	<div id="bodyContent">
		<h3 id="siteSub">出自TDW WIKI</h3>
		<div id="contentSub"></div>
		<div id="jump-to-nav">跳转到： <a href="#column-one">导航</a>, <a href="#searchInput">搜索</a></div>
		<!-- start content -->
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>目录</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.E5.87.BD.E6.95.B0.E5.B8.AE.E5.8A.A9.E4.BF.A1.E6.81.AF"><span class="tocnumber">1</span> <span class="toctext">函数帮助信息</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#TDW.E6.89.A9.E5.B1.95.E5.87.BD.E6.95.B0"><span class="tocnumber">2</span> <span class="toctext">TDW扩展函数</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#.E6.99.AE.E9.80.9A.E5.87.BD.E6.95.B0"><span class="tocnumber">2.1</span> <span class="toctext">普通函数</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#add_months.28_date.2C_n_.29"><span class="tocnumber">2.1.1</span> <span class="toctext">add_months( date, n )</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#trunc.28_date.2C_.5B_format_.5D_.29"><span class="tocnumber">2.1.2</span> <span class="toctext">trunc( date, [ format ] )</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#trunc.28_number.2C_.5B_decimal_places_.5D_.29"><span class="tocnumber">2.1.3</span> <span class="toctext">trunc( number, [ decimal_places ] )</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#months_between.28_date1.2C_date2_.29"><span class="tocnumber">2.1.4</span> <span class="toctext">months_between( date1, date2 )</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#convert.28_string1_.2C_char_set_to_.2C_char_set_from.29"><span class="tocnumber">2.1.5</span> <span class="toctext">convert( string1 , char_set_to , char_set_from)</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#last_day.28date.29"><span class="tocnumber">2.1.6</span> <span class="toctext">last_day(date)</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#tz_offset.28_timezone_.29"><span class="tocnumber">2.1.7</span> <span class="toctext">tz_offset( timezone )</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#sessiontimezone.28.29"><span class="tocnumber">2.1.8</span> <span class="toctext">sessiontimezone()</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#sign.28_number_.29"><span class="tocnumber">2.1.9</span> <span class="toctext">sign( number )</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#chr.28_number_code_.29"><span class="tocnumber">2.1.10</span> <span class="toctext">chr( number_code )</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#least.28_expr1.2C_expr2.2C_..._expr_n_.29"><span class="tocnumber">2.1.11</span> <span class="toctext">least( expr1, expr2, ... expr_n )</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#greatest.28_expr1.2C_expr2.2C_..._expr_n_.29"><span class="tocnumber">2.1.12</span> <span class="toctext">greatest( expr1, expr2, ... expr_n )</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#NVL.28expr1.2Cexpr2_.29"><span class="tocnumber">2.1.13</span> <span class="toctext">NVL(expr1,expr2 )</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#NVL2.28expr1.2Cexpr2.2C_expr3.29"><span class="tocnumber">2.1.14</span> <span class="toctext">NVL2(expr1,expr2, expr3)</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#SYSTIMESTAMP.28.29"><span class="tocnumber">2.1.15</span> <span class="toctext">SYSTIMESTAMP()</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#INSTR.28.28string.2Cstr.5B.2Cstart.5D.5B.2Cappear.5D.29"><span class="tocnumber">2.1.16</span> <span class="toctext">INSTR((string,str[,start][,appear])</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#MOD.28_n1.2C_n2_.29"><span class="tocnumber">2.1.17</span> <span class="toctext">MOD( n1, n2 )</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#BITAND.28expr1.2C_expr2.29"><span class="tocnumber">2.1.18</span> <span class="toctext">BITAND(expr1, expr2)</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#NEXT_DAY.28date.2Cday.29"><span class="tocnumber">2.1.19</span> <span class="toctext">NEXT_DAY(date,day)</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#TO_NUMBER.28string.29"><span class="tocnumber">2.1.20</span> <span class="toctext">TO_NUMBER(string)</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#TO_CHAR.28date.2Cformat.EF.BC.89"><span class="tocnumber">2.1.21</span> <span class="toctext">TO_CHAR(date,format）</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#TO_DATE.28date.EF.BC.8Cformat.29"><span class="tocnumber">2.1.22</span> <span class="toctext">TO_DATE(date，format)</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#expr_.5BNOT.5D_IN_.28expr1.5B.2C_expr2.2C....5D.29"><span class="tocnumber">2.1.23</span> <span class="toctext">expr [NOT] IN (expr1[, expr2,...])</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#.5BNOT.5D_EXISTS_.28SELECT_..._FROM_..._WHERE_....29"><span class="tocnumber">2.1.24</span> <span class="toctext">[NOT] EXISTS (SELECT ... FROM ... WHERE ...)</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#wm_concat.28col1.5B.2Csplitstr.5B.2C.27desc.27.5B.2Ccol2.5D.5D.5D.29"><span class="tocnumber">2.1.25</span> <span class="toctext">wm_concat(col1[,splitstr[,'desc'[,col2]]])</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#decode.28expression_.2C_search_.2C_result_.5B.2C_search_.2C_result.5D..._.5B.2C_default.5D.29"><span class="tocnumber">2.1.26</span> <span class="toctext">decode(expression , search , result [, search , result]... [, default])</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#a_.7C.7C_b_.E4.BD.9C.E4.B8.BAconcat.E5.87.BD.E6.95.B0.E7.9A.84.E7.AE.80.E5.8C.96"><span class="tocnumber">2.1.27</span> <span class="toctext">a &#124;&#124; b 作为concat函数的简化</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#between"><span class="tocnumber">2.1.28</span> <span class="toctext">between</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#numformat"><span class="tocnumber">2.1.29</span> <span class="toctext">numformat</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#commonStr.28string.2Cstring.2Cstring.29"><span class="tocnumber">2.1.30</span> <span class="toctext">commonStr(string,string,string)</span></a></li>
<li class="toclevel-3 tocsection-34"><a href="#md5.28long.2Fdouble.2Fint.2Fstring.2Clong.2Fdouble.2Fint.2Fstring.29"><span class="tocnumber">2.1.31</span> <span class="toctext">md5(long/double/int/string,long/double/int/string)</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="#.E7.89.B9.E5.88.AB.E8.AF.B4.E6.98.8E"><span class="tocnumber">2.1.32</span> <span class="toctext">特别说明</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-36"><a href="#.E9.AB.98.E7.BA.A7.E5.88.86.E6.9E.90.E5.87.BD.E6.95.B0"><span class="tocnumber">2.2</span> <span class="toctext">高级分析函数</span></a>
<ul>
<li class="toclevel-3 tocsection-37"><a href="#LAG_.28_value_expr_.5B.2C_offset_.5D_.5B.2C_default.5D_.29OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"><span class="tocnumber">2.2.1</span> <span class="toctext">LAG ( value_expr [, offset ] [, default] )OVER ( [query_partition_clause] order_by_clause )</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="#LEAD_.28value_expr_.5B.2C_offset_.5D_.5B.2C_default_.5D_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"><span class="tocnumber">2.2.2</span> <span class="toctext">LEAD (value_expr [, offset ] [, default ] ) OVER ( [query_partition_clause] order_by_clause )</span></a></li>
<li class="toclevel-3 tocsection-39"><a href="#RANK_.28_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"><span class="tocnumber">2.2.3</span> <span class="toctext">RANK ( ) OVER ( [query_partition_clause] order_by_clause )</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="#DENSE_RANK_.28_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"><span class="tocnumber">2.2.4</span> <span class="toctext">DENSE_RANK ( ) OVER ( [query_partition_clause] order_by_clause )</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="#ROW_NUMBER_.28_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"><span class="tocnumber">2.2.5</span> <span class="toctext">ROW_NUMBER ( ) OVER ( [query_partition_clause] order_by_clause )</span></a></li>
<li class="toclevel-3 tocsection-42"><a href="#SUM_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause_.5D_.29"><span class="tocnumber">2.2.6</span> <span class="toctext">SUM ( [ DISTINCT ] expr )OVER ( [query_partition_clause] [order_by_clause ] )</span></a></li>
<li class="toclevel-3 tocsection-43"><a href="#COUNT.28_1_.7C_.5B_DISTINCT_.5D_expr.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"><span class="tocnumber">2.2.7</span> <span class="toctext">COUNT( 1 &#124; [ DISTINCT ] expr)OVER ( [query_partition_clause] [order_by_clause] )</span></a></li>
<li class="toclevel-3 tocsection-44"><a href="#AVG_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"><span class="tocnumber">2.2.8</span> <span class="toctext">AVG ( [ DISTINCT ] expr )OVER ([query_partition_clause] [order_by_clause] )</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="#MAX_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"><span class="tocnumber">2.2.9</span> <span class="toctext">MAX ( [ DISTINCT ] expr )OVER ( [query_partition_clause] [order_by_clause] )</span></a></li>
<li class="toclevel-3 tocsection-46"><a href="#MIN_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"><span class="tocnumber">2.2.10</span> <span class="toctext">MIN ( [ DISTINCT ] expr )OVER ( [query_partition_clause] [order_by_clause] )</span></a></li>
<li class="toclevel-3 tocsection-47"><a href="#RATIO_TO_REPORT_.28_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"><span class="tocnumber">2.2.11</span> <span class="toctext">RATIO_TO_REPORT ( expr )OVER ( [query_partition_clause] [order_by_clause] )</span></a></li>
<li class="toclevel-3 tocsection-48"><a href="#FIRST_VALUE_.28_expr_.29_OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"><span class="tocnumber">2.2.12</span> <span class="toctext">FIRST_VALUE ( expr ) OVER ( [query_partition_clause] [order_by_clause] )</span></a></li>
<li class="toclevel-3 tocsection-49"><a href="#LAST_VALUE_.28_expr_.29_OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"><span class="tocnumber">2.2.13</span> <span class="toctext">LAST_VALUE ( expr ) OVER ( [query_partition_clause] [order_by_clause] )</span></a></li>
<li class="toclevel-3 tocsection-50"><a href="#.E7.89.B9.E5.88.AB.E8.AF.B4.E6.98.8E_2"><span class="tocnumber">2.2.14</span> <span class="toctext">特别说明</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="#.E9.99.90.E5.AE.9A"><span class="tocnumber">2.2.15</span> <span class="toctext">限定</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-52"><a href="#HIVE.E5.86.85.E7.BD.AE.E6.93.8D.E4.BD.9C.E7.AC.A6"><span class="tocnumber">3</span> <span class="toctext">HIVE内置操作符</span></a>
<ul>
<li class="toclevel-2 tocsection-53"><a href="#.E5.85.B3.E7.B3.BB.E6.93.8D.E4.BD.9C.E7.AC.A6"><span class="tocnumber">3.1</span> <span class="toctext">关系操作符</span></a>
<ul>
<li class="toclevel-3 tocsection-54"><a href="#A_.3D_B"><span class="tocnumber">3.1.1</span> <span class="toctext">A = B</span></a></li>
<li class="toclevel-3 tocsection-55"><a href="#A_.3D.3D_B"><span class="tocnumber">3.1.2</span> <span class="toctext">A == B</span></a></li>
<li class="toclevel-3 tocsection-56"><a href="#A_.3C.3E_B"><span class="tocnumber">3.1.3</span> <span class="toctext">A &lt;&gt; B</span></a></li>
<li class="toclevel-3 tocsection-57"><a href="#A_.3C_B"><span class="tocnumber">3.1.4</span> <span class="toctext">A &lt; B</span></a></li>
<li class="toclevel-3 tocsection-58"><a href="#A_.3C.3D_B"><span class="tocnumber">3.1.5</span> <span class="toctext">A &lt;= B</span></a></li>
<li class="toclevel-3 tocsection-59"><a href="#A_.3E_B"><span class="tocnumber">3.1.6</span> <span class="toctext">A &gt; B</span></a></li>
<li class="toclevel-3 tocsection-60"><a href="#A_.3E.3D_B"><span class="tocnumber">3.1.7</span> <span class="toctext">A &gt;= B</span></a></li>
<li class="toclevel-3 tocsection-61"><a href="#A_IS_NULL"><span class="tocnumber">3.1.8</span> <span class="toctext">A IS NULL</span></a></li>
<li class="toclevel-3 tocsection-62"><a href="#A_IS_NOT_NULL"><span class="tocnumber">3.1.9</span> <span class="toctext">A IS NOT NULL</span></a></li>
<li class="toclevel-3 tocsection-63"><a href="#A_LIKE_B"><span class="tocnumber">3.1.10</span> <span class="toctext">A LIKE B</span></a></li>
<li class="toclevel-3 tocsection-64"><a href="#A_RLIKE_B"><span class="tocnumber">3.1.11</span> <span class="toctext">A RLIKE B</span></a></li>
<li class="toclevel-3 tocsection-65"><a href="#A_REGEXP_B"><span class="tocnumber">3.1.12</span> <span class="toctext">A REGEXP B</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-66"><a href="#.E7.AE.97.E6.95.B0.E6.93.8D.E4.BD.9C.E7.AC.A6"><span class="tocnumber">3.2</span> <span class="toctext">算数操作符</span></a>
<ul>
<li class="toclevel-3 tocsection-67"><a href="#A_.2B_B"><span class="tocnumber">3.2.1</span> <span class="toctext">A + B</span></a></li>
<li class="toclevel-3 tocsection-68"><a href="#A_-_B"><span class="tocnumber">3.2.2</span> <span class="toctext">A - B</span></a></li>
<li class="toclevel-3 tocsection-69"><a href="#A_.2A_B"><span class="tocnumber">3.2.3</span> <span class="toctext">A * B</span></a></li>
<li class="toclevel-3 tocsection-70"><a href="#A_.2F_B"><span class="tocnumber">3.2.4</span> <span class="toctext">A / B</span></a></li>
<li class="toclevel-3 tocsection-71"><a href="#A.C2.A0.25_B"><span class="tocnumber">3.2.5</span> <span class="toctext">A&nbsp;% B</span></a></li>
<li class="toclevel-3 tocsection-72"><a href="#A_.26_B"><span class="tocnumber">3.2.6</span> <span class="toctext">A &amp; B</span></a></li>
<li class="toclevel-3 tocsection-73"><a href="#A_.7C_B"><span class="tocnumber">3.2.7</span> <span class="toctext">A &#124; B</span></a></li>
<li class="toclevel-3 tocsection-74"><a href="#A_.5E_B"><span class="tocnumber">3.2.8</span> <span class="toctext">A ^ B</span></a></li>
<li class="toclevel-3 tocsection-75"><a href="#.7EA"><span class="tocnumber">3.2.9</span> <span class="toctext">~A</span></a></li>
<li class="toclevel-3 tocsection-76"><a href="#A_.3C.3C_B"><span class="tocnumber">3.2.10</span> <span class="toctext">A &lt;&lt; B</span></a></li>
<li class="toclevel-3 tocsection-77"><a href="#A_.3E.3E_B"><span class="tocnumber">3.2.11</span> <span class="toctext">A &gt;&gt; B</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-78"><a href="#.E9.80.BB.E8.BE.91.E6.93.8D.E4.BD.9C.E7.AC.A6"><span class="tocnumber">3.3</span> <span class="toctext">逻辑操作符</span></a>
<ul>
<li class="toclevel-3 tocsection-79"><a href="#A_AND_B"><span class="tocnumber">3.3.1</span> <span class="toctext">A AND B</span></a></li>
<li class="toclevel-3 tocsection-80"><a href="#A_.26.26_B"><span class="tocnumber">3.3.2</span> <span class="toctext">A &amp;&amp; B</span></a></li>
<li class="toclevel-3 tocsection-81"><a href="#A_OR_B"><span class="tocnumber">3.3.3</span> <span class="toctext">A OR B</span></a></li>
<li class="toclevel-3 tocsection-82"><a href="#NOT_A"><span class="tocnumber">3.3.4</span> <span class="toctext">NOT A</span></a></li>
<li class="toclevel-3 tocsection-83"><a href="#.C2.A0.21A"><span class="tocnumber">3.3.5</span> <span class="toctext">&nbsp;!A</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-84"><a href="#HIVE.E5.86.85.E7.BD.AE.E5.87.BD.E6.95.B0"><span class="tocnumber">4</span> <span class="toctext">HIVE内置函数</span></a>
<ul>
<li class="toclevel-2 tocsection-85"><a href="#.E6.95.B0.E5.AD.A6.E5.87.BD.E6.95.B0"><span class="tocnumber">4.1</span> <span class="toctext">数学函数</span></a>
<ul>
<li class="toclevel-3 tocsection-86"><a href="#round.28double_a.29"><span class="tocnumber">4.1.1</span> <span class="toctext">round(double a)</span></a></li>
<li class="toclevel-3 tocsection-87"><a href="#floor.28double_a.29"><span class="tocnumber">4.1.2</span> <span class="toctext">floor(double a)</span></a></li>
<li class="toclevel-3 tocsection-88"><a href="#ceil.28double_a.29.2Cceiling.28double_a.29"><span class="tocnumber">4.1.3</span> <span class="toctext">ceil(double a),ceiling(double a)</span></a></li>
<li class="toclevel-3 tocsection-89"><a href="#rand.28.29.2Crand.28int_seed.29"><span class="tocnumber">4.1.4</span> <span class="toctext">rand(),rand(int seed)</span></a></li>
<li class="toclevel-3 tocsection-90"><a href="#exp.28double_a.29"><span class="tocnumber">4.1.5</span> <span class="toctext">exp(double a)</span></a></li>
<li class="toclevel-3 tocsection-91"><a href="#ln.28double_a.29"><span class="tocnumber">4.1.6</span> <span class="toctext">ln(double a)</span></a></li>
<li class="toclevel-3 tocsection-92"><a href="#log10.28double_a.29"><span class="tocnumber">4.1.7</span> <span class="toctext">log10(double a)</span></a></li>
<li class="toclevel-3 tocsection-93"><a href="#log2.28double_a.29"><span class="tocnumber">4.1.8</span> <span class="toctext">log2(double a)</span></a></li>
<li class="toclevel-3 tocsection-94"><a href="#log.28double_base.2Cdouble_a.29"><span class="tocnumber">4.1.9</span> <span class="toctext">log(double base,double a)</span></a></li>
<li class="toclevel-3 tocsection-95"><a href="#pow.28double_a.2Cdouble_p.29.2Cpower.28double_a.2Cdouble_p.29"><span class="tocnumber">4.1.10</span> <span class="toctext">pow(double a,double p),power(double a,double p)</span></a></li>
<li class="toclevel-3 tocsection-96"><a href="#sqrt.28double_a.29"><span class="tocnumber">4.1.11</span> <span class="toctext">sqrt(double a)</span></a></li>
<li class="toclevel-3 tocsection-97"><a href="#bin.28BIGINT_a.29"><span class="tocnumber">4.1.12</span> <span class="toctext">bin(BIGINT a)</span></a></li>
<li class="toclevel-3 tocsection-98"><a href="#hex.28BIGINT_a.29.2Chex.28string_a.29"><span class="tocnumber">4.1.13</span> <span class="toctext">hex(BIGINT a),hex(string a)</span></a></li>
<li class="toclevel-3 tocsection-99"><a href="#unhex.28string_a.29"><span class="tocnumber">4.1.14</span> <span class="toctext">unhex(string a)</span></a></li>
<li class="toclevel-3 tocsection-100"><a href="#conv.28BIGINT_num.2Cint_from_base.2Cint_to_base.29"><span class="tocnumber">4.1.15</span> <span class="toctext">conv(BIGINT num,int from_base,int to_base)</span></a></li>
<li class="toclevel-3 tocsection-101"><a href="#abs.28double_a.29"><span class="tocnumber">4.1.16</span> <span class="toctext">abs(double a)</span></a></li>
<li class="toclevel-3 tocsection-102"><a href="#pmod.28int_a.2Cint_b.29.2Cpmod.28double_a.2Cdouble_b.29"><span class="tocnumber">4.1.17</span> <span class="toctext">pmod(int a,int b),pmod(double a,double b)</span></a></li>
<li class="toclevel-3 tocsection-103"><a href="#sin.28double_a.29"><span class="tocnumber">4.1.18</span> <span class="toctext">sin(double a)</span></a></li>
<li class="toclevel-3 tocsection-104"><a href="#asin.28double_a.29"><span class="tocnumber">4.1.19</span> <span class="toctext">asin(double a)</span></a></li>
<li class="toclevel-3 tocsection-105"><a href="#cos.28double_a.29"><span class="tocnumber">4.1.20</span> <span class="toctext">cos(double a)</span></a></li>
<li class="toclevel-3 tocsection-106"><a href="#acos.28double_a.29"><span class="tocnumber">4.1.21</span> <span class="toctext">acos(double a)</span></a></li>
<li class="toclevel-3 tocsection-107"><a href="#positive.28int_a.29.2Cpositive.28double_a.29"><span class="tocnumber">4.1.22</span> <span class="toctext">positive(int a),positive(double a)</span></a></li>
<li class="toclevel-3 tocsection-108"><a href="#negative.28int_a.29.2Cnegative.28double_a.29"><span class="tocnumber">4.1.23</span> <span class="toctext">negative(int a),negative(double a)</span></a></li>
<li class="toclevel-3 tocsection-109"><a href="#percentile.28BIGINT_col.2C_p.29"><span class="tocnumber">4.1.24</span> <span class="toctext">percentile(BIGINT col, p)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-110"><a href="#.E7.B1.BB.E5.9E.8B.E8.BD.AC.E6.8D.A2.E5.87.BD.E6.95.B0"><span class="tocnumber">4.2</span> <span class="toctext">类型转换函数</span></a>
<ul>
<li class="toclevel-3 tocsection-111"><a href="#cast.28expr_as_.3Ctype.3E.29"><span class="tocnumber">4.2.1</span> <span class="toctext">cast(expr as &lt;type&gt;)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-112"><a href="#.E6.97.B6.E9.97.B4.E5.87.BD.E6.95.B0"><span class="tocnumber">4.3</span> <span class="toctext">时间函数</span></a>
<ul>
<li class="toclevel-3 tocsection-113"><a href="#from_unixtime.28int_unixtime_.5B.2C_pattern.5D.29"><span class="tocnumber">4.3.1</span> <span class="toctext">from_unixtime(int unixtime [, pattern])</span></a></li>
<li class="toclevel-3 tocsection-114"><a href="#unix_timestamp.28.29"><span class="tocnumber">4.3.2</span> <span class="toctext">unix_timestamp()</span></a></li>
<li class="toclevel-3 tocsection-115"><a href="#unix_timestamp.28string_date_.5B.2C_pattern.5D.29"><span class="tocnumber">4.3.3</span> <span class="toctext">unix_timestamp(string date [, pattern])</span></a></li>
<li class="toclevel-3 tocsection-116"><a href="#year.28string_date.29"><span class="tocnumber">4.3.4</span> <span class="toctext">year(string date)</span></a></li>
<li class="toclevel-3 tocsection-117"><a href="#month.28string_date.29"><span class="tocnumber">4.3.5</span> <span class="toctext">month(string date)</span></a></li>
<li class="toclevel-3 tocsection-118"><a href="#day.28string_date.29.2Cdayofmonth.28string_date.29"><span class="tocnumber">4.3.6</span> <span class="toctext">day(string date),dayofmonth(string date)</span></a></li>
<li class="toclevel-3 tocsection-119"><a href="#hour.28string_date.29"><span class="tocnumber">4.3.7</span> <span class="toctext">hour(string date)</span></a></li>
<li class="toclevel-3 tocsection-120"><a href="#minute.28string_date.29"><span class="tocnumber">4.3.8</span> <span class="toctext">minute(string date)</span></a></li>
<li class="toclevel-3 tocsection-121"><a href="#second.28string_date.29"><span class="tocnumber">4.3.9</span> <span class="toctext">second(string date)</span></a></li>
<li class="toclevel-3 tocsection-122"><a href="#weekofyear.28string_date.29"><span class="tocnumber">4.3.10</span> <span class="toctext">weekofyear(string date)</span></a></li>
<li class="toclevel-3 tocsection-123"><a href="#week.28string_date.29"><span class="tocnumber">4.3.11</span> <span class="toctext">week(string date)</span></a></li>
<li class="toclevel-3 tocsection-124"><a href="#commonStr.28col1.2Ccol2.2Cseparator.29"><span class="tocnumber">4.3.12</span> <span class="toctext">commonStr(col1,col2,separator)</span></a></li>
<li class="toclevel-3 tocsection-125"><a href="#datediff.28string_enddate.2Cstring_startdate.29"><span class="tocnumber">4.3.13</span> <span class="toctext">datediff(string enddate,string startdate)</span></a></li>
<li class="toclevel-3 tocsection-126"><a href="#date_add.28string_startdate.2Cint_days.29"><span class="tocnumber">4.3.14</span> <span class="toctext">date_add(string startdate,int days)</span></a></li>
<li class="toclevel-3 tocsection-127"><a href="#date_sub.28string_startdate.2Cint_days.29"><span class="tocnumber">4.3.15</span> <span class="toctext">date_sub(string startdate,int days)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-128"><a href="#.E6.9D.A1.E4.BB.B6.E5.87.BD.E6.95.B0"><span class="tocnumber">4.4</span> <span class="toctext">条件函数</span></a>
<ul>
<li class="toclevel-3 tocsection-129"><a href="#if.28boolean_test_Condition.2C_T_value_TRUE.2C_T_value_FALSE_or_NULL.29"><span class="tocnumber">4.4.1</span> <span class="toctext">if(boolean test Condition, T value TRUE, T value FALSE or NULL)</span></a></li>
<li class="toclevel-3 tocsection-130"><a href="#COALESCE.28T_v1.2C_T_v2.2C_....29"><span class="tocnumber">4.4.2</span> <span class="toctext">COALESCE(T v1, T v2, ...)</span></a></li>
<li class="toclevel-3 tocsection-131"><a href="#CASE_a_WHEN_b_THEN_c_.5BWHEN_d_THEN_e.5D.2A_.5BELSE_f.5D_END"><span class="tocnumber">4.4.3</span> <span class="toctext">CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END</span></a></li>
<li class="toclevel-3 tocsection-132"><a href="#CASE_WHEN_a_THEN_b_.5BWHEN_c_THEN_d.5D.2A_.5BELSE_e.5D_END"><span class="tocnumber">4.4.4</span> <span class="toctext">CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-133"><a href="#.E5.AD.97.E7.AC.A6.E4.B8.B2.E5.87.BD.E6.95.B0"><span class="tocnumber">4.5</span> <span class="toctext">字符串函数</span></a>
<ul>
<li class="toclevel-3 tocsection-134"><a href="#length.28string_A.29"><span class="tocnumber">4.5.1</span> <span class="toctext">length(string A)</span></a></li>
<li class="toclevel-3 tocsection-135"><a href="#reverse.28string_A.29"><span class="tocnumber">4.5.2</span> <span class="toctext">reverse(string A)</span></a></li>
<li class="toclevel-3 tocsection-136"><a href="#concat.28string_A.2Cstring_B.29"><span class="tocnumber">4.5.3</span> <span class="toctext">concat(string A,string B)</span></a></li>
<li class="toclevel-3 tocsection-137"><a href="#substr.28string_A.2Cint_start.29.2Csubstring.28string_A.2C_int_start.29"><span class="tocnumber">4.5.4</span> <span class="toctext">substr(string A,int start),substring(string A, int start)</span></a></li>
<li class="toclevel-3 tocsection-138"><a href="#substr.28string_A.2Cint_start.2Cint_len.29.2Csubstring.28string_A.2C_int_start.2Cint_len.29"><span class="tocnumber">4.5.5</span> <span class="toctext">substr(string A,int start,int len),substring(string A, int start,int len)</span></a></li>
<li class="toclevel-3 tocsection-139"><a href="#upper.28string_A.29.2Cucase.28string_A.29"><span class="tocnumber">4.5.6</span> <span class="toctext">upper(string A),ucase(string A)</span></a></li>
<li class="toclevel-3 tocsection-140"><a href="#lower.28string_A.29.2Clcase.28string_A.29"><span class="tocnumber">4.5.7</span> <span class="toctext">lower(string A),lcase(string A)</span></a></li>
<li class="toclevel-3 tocsection-141"><a href="#trim.28string_A.29"><span class="tocnumber">4.5.8</span> <span class="toctext">trim(string A)</span></a></li>
<li class="toclevel-3 tocsection-142"><a href="#ltrim.28string_A.29"><span class="tocnumber">4.5.9</span> <span class="toctext">ltrim(string A)</span></a></li>
<li class="toclevel-3 tocsection-143"><a href="#rtrim.28string_A.29"><span class="tocnumber">4.5.10</span> <span class="toctext">rtrim(string A)</span></a></li>
<li class="toclevel-3 tocsection-144"><a href="#regexp_replace.28string_A.2C_string_B.2C_string_C.29"><span class="tocnumber">4.5.11</span> <span class="toctext">regexp_replace(string A, string B, string C)</span></a></li>
<li class="toclevel-3 tocsection-145"><a href="#regexp_extract.28string_subject.2C_string_pattern.2C_int_intex.29"><span class="tocnumber">4.5.12</span> <span class="toctext">regexp_extract(string subject, string pattern, int intex)</span></a></li>
<li class="toclevel-3 tocsection-146"><a href="#regexp_instr.28source_char.2Cpattern.5B.2Cposition_.5B.2Coccurrence.5B.2Creturn_option.5B.2Cmatch_parameter.5D.5D.5D.5D.29"><span class="tocnumber">4.5.13</span> <span class="toctext">regexp_instr(source_char,pattern[,position [,occurrence[,return_option[,match_parameter]]]])</span></a></li>
<li class="toclevel-3 tocsection-147"><a href="#parse_url.28string_urlString.2C_string_partToExtract_.5B.2C_string_keyToExtract.5D.29"><span class="tocnumber">4.5.14</span> <span class="toctext">parse_url(string urlString, string partToExtract [, string keyToExtract])</span></a></li>
<li class="toclevel-3 tocsection-148"><a href="#get_json_object.28string_json_string.2C_string_path.29"><span class="tocnumber">4.5.15</span> <span class="toctext">get_json_object(string json_string, string path)</span></a></li>
<li class="toclevel-3 tocsection-149"><a href="#space.28int_n.29"><span class="tocnumber">4.5.16</span> <span class="toctext">space(int n)</span></a></li>
<li class="toclevel-3 tocsection-150"><a href="#repeat.28string_str.2C_int_n.29"><span class="tocnumber">4.5.17</span> <span class="toctext">repeat(string str, int n)</span></a></li>
<li class="toclevel-3 tocsection-151"><a href="#ascii.28string_str.29"><span class="tocnumber">4.5.18</span> <span class="toctext">ascii(string str)</span></a></li>
<li class="toclevel-3 tocsection-152"><a href="#lpad.28string_str.2C_int_len.2C_string_pad.29"><span class="tocnumber">4.5.19</span> <span class="toctext">lpad(string str, int len, string pad)</span></a></li>
<li class="toclevel-3 tocsection-153"><a href="#rpad.28string_str.2C_int_len.2C_string_pad.29"><span class="tocnumber">4.5.20</span> <span class="toctext">rpad(string str, int len, string pad)</span></a></li>
<li class="toclevel-3 tocsection-154"><a href="#url_decode.28string_url_string.2C_string_encode.29"><span class="tocnumber">4.5.21</span> <span class="toctext">url_decode(string url_string, string encode)</span></a></li>
<li class="toclevel-3 tocsection-155"><a href="#split.28string_str.2C_string_regex.29"><span class="tocnumber">4.5.22</span> <span class="toctext">split(string str, string regex)</span></a></li>
<li class="toclevel-3 tocsection-156"><a href="#size.28array_arr.29"><span class="tocnumber">4.5.23</span> <span class="toctext">size(array arr)</span></a></li>
<li class="toclevel-3 tocsection-157"><a href="#array_contains.28array_arr.2C_element.29"><span class="tocnumber">4.5.24</span> <span class="toctext">array_contains(array arr, element)</span></a></li>
<li class="toclevel-3 tocsection-158"><a href="#get_main_domain.28string_url_string.29"><span class="tocnumber">4.5.25</span> <span class="toctext">get_main_domain(string url_string)</span></a></li>
<li class="toclevel-3 tocsection-159"><a href="#parse_xml_count.28string_xml_string.2C_string_root_label.2C_string_sub_label_....29"><span class="tocnumber">4.5.26</span> <span class="toctext">parse_xml_count(string xml_string, string root_label, string sub_label ...)</span></a></li>
<li class="toclevel-3 tocsection-160"><a href="#parse_xml_content.28string_xml_string.2C_string_root_label.2C_string_sub_label_....29"><span class="tocnumber">4.5.27</span> <span class="toctext">parse_xml_content(string xml_string, string root_label, string sub_label ...)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-161"><a href="#IP.E5.87.BD.E6.95.B0"><span class="tocnumber">4.6</span> <span class="toctext">IP函数</span></a>
<ul>
<li class="toclevel-3 tocsection-162"><a href="#inet_aton.28string_addr.29"><span class="tocnumber">4.6.1</span> <span class="toctext">inet_aton(string addr)</span></a></li>
<li class="toclevel-3 tocsection-163"><a href="#inet_ntoa.28bigint_addr.29"><span class="tocnumber">4.6.2</span> <span class="toctext">inet_ntoa(bigint addr)</span></a></li>
<li class="toclevel-3 tocsection-164"><a href="#ipinfo.28string_ip_table.2Cbigint_ip.2Cint_index.29"><span class="tocnumber">4.6.3</span> <span class="toctext">ipinfo(string ip_table,bigint ip,int index)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-165"><a href="#.E8.81.9A.E5.90.88.E5.87.BD.E6.95.B0"><span class="tocnumber">4.7</span> <span class="toctext">聚合函数</span></a>
<ul>
<li class="toclevel-3 tocsection-166"><a href="#count.28.21.29.2C_count.28expr.29.2C_count.28DISTINCT_expr.5B.2C_expr....5D.29"><span class="tocnumber">4.7.1</span> <span class="toctext">count(!), count(expr), count(DISTINCT expr[, expr...])</span></a></li>
<li class="toclevel-3 tocsection-167"><a href="#sum.28col.29.2Csum.28DISTINCT_col.29"><span class="tocnumber">4.7.2</span> <span class="toctext">sum(col),sum(DISTINCT col)</span></a></li>
<li class="toclevel-3 tocsection-168"><a href="#avg.28col.29.2Cavg.28DISTINCT_col.29"><span class="tocnumber">4.7.3</span> <span class="toctext">avg(col),avg(DISTINCT col)</span></a></li>
<li class="toclevel-3 tocsection-169"><a href="#min.28col.29"><span class="tocnumber">4.7.4</span> <span class="toctext">min(col)</span></a></li>
<li class="toclevel-3 tocsection-170"><a href="#max.28col.29"><span class="tocnumber">4.7.5</span> <span class="toctext">max(col)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-171"><a href="#.E6.95.B0.E6.8D.AE.E6.8C.96.E6.8E.98.E4.B8.8E.E7.BB.9F.E8.AE.A1.E5.88.86.E6.9E.90.E5.87.BD.E6.95.B0"><span class="tocnumber">5</span> <span class="toctext">数据挖掘与统计分析函数</span></a>
<ul>
<li class="toclevel-2 tocsection-172"><a href="#sentences.28string_str.2C_string_lang.2C_string_locale.29"><span class="tocnumber">5.1</span> <span class="toctext">sentences(string str, string lang, string locale)</span></a></li>
<li class="toclevel-2 tocsection-173"><a href="#ngrams.28array.3Carray.3Cstring.3E.3E.2C_int_n.2C_int_k.2C_int_pf.29"><span class="tocnumber">5.2</span> <span class="toctext">ngrams(array&lt;array&lt;string&gt;&gt;, int n, int k, int pf)</span></a></li>
<li class="toclevel-2 tocsection-174"><a href="#context_ngrams.28expr_array.3CString.3E.2Ccontext_array.3Cstring1.2Cstring2.2C....3E.2Ck_int.2Cpf_int.29"><span class="tocnumber">5.3</span> <span class="toctext">context_ngrams(expr array&lt;String&gt;,context array&lt;string1,string2,...&gt;,k int,pf int)</span></a></li>
<li class="toclevel-2 tocsection-175"><a href="#covar_pop.28_dependent-expression.2C_independent-expression_.29"><span class="tocnumber">5.4</span> <span class="toctext">covar_pop( dependent-expression, independent-expression )</span></a></li>
<li class="toclevel-2 tocsection-176"><a href="#covar_samp.28_dependent-expression.2C_independent-expression_.29"><span class="tocnumber">5.5</span> <span class="toctext">covar_samp( dependent-expression, independent-expression )</span></a></li>
<li class="toclevel-2 tocsection-177"><a href="#corr.28X.2CY.29"><span class="tocnumber">5.6</span> <span class="toctext">corr(X,Y)</span></a></li>
</ul>
</li>
</ul>
</td></tr></table><script>if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
<h2> <span class="mw-headline" id=".E5.87.BD.E6.95.B0.E5.B8.AE.E5.8A.A9.E4.BF.A1.E6.81.AF"> 函数帮助信息 </span></h2>
<p>在TDW客户端通过一下命令，可以查看TDW支持的内置函数
</p><p>显示所有内置函数：
</p>
<pre>SHOW FUNCTIONS;
</pre>
<p>显示一个内置函数的简要说明：
</p>
<pre>DESCRIBE FUNCTION &lt;function_name&gt;;
</pre>
<p>显示一个内置函数的更详细说明：
</p>
<pre>DESCRIBE FUNCTION EXTENDED &lt;function_name&gt;;
</pre>
<h2> <span class="mw-headline" id="TDW.E6.89.A9.E5.B1.95.E5.87.BD.E6.95.B0"> TDW扩展函数 </span></h2>
<h3> <span class="mw-headline" id=".E6.99.AE.E9.80.9A.E5.87.BD.E6.95.B0"> 普通函数 </span></h3>
<table border="1">

<tr>
<td> 返回值
</td><td> 函数名
</td><td> 说明
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="add_months.28_date.2C_n_.29"> add_months( date, n ) </span></h4>
</td><td> Returns a date plus n months.
<p>date is the starting date (before the n months have been added). n is the number of months to add to date. 注：目前输入的date格式为"yyyy-MM-dd"或者"yyyyMMdd"（以这个格式开头的都可以接受，否则返回null，下面同上），返回字符串也是这个格式。 注：n为int型整数（<b>Hive中int型范围为正负2147483647区间，bigint类型的范围为正负9223372036854775807，以下同上</b>），表示在date上增减的月份数。 注：输入如“2008-1-33”的情况不会报错，当作“2008-2-2”处理，下面几个函数同上。 本函数将时间年限范围设定为[1900, 9999]， 暂不支持公元前纪年，时间输入错误或者是计算溢出则返回null。
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="trunc.28_date.2C_.5B_format_.5D_.29"> trunc( date, [ format ] ) </span></h4>
</td><td> Returns a date truncated to a specific unit of measure.
<p>date is the date to truncate. format is the unit of measure to apply for truncating. If the format parameter is omitted, the function will truncate the date to the day value, so that any hours, minutes, or seconds will be truncated off. 目前函数的date参数的输入格式为"yyyy-MM-dd HH:mm:ss"（字符串以这个格式开头即可，否则返回null），返回字符串也是这个格式。 注：输入如“2008-1-33”的情况不会报错，当作“2008-2-2”处理。
</p><p>目前支持的format形式有：
</p><p>Year SYYYY, YYYY, YEAR,SYEAR, YYY, YY, Y
</p><p>Month MONTH, MON, MM, RM
</p><p>Week WW
</p><p>W W
</p><p>Day DDD, DD, J
</p><p>Start day of the week DAY, DY, D
</p><p>Hour HH, HH12, HH24
</p><p>Minute MI
</p><p>暂不支持ISO Year，Quarter和IW。例如：
</p><p>trunc('22-AUG-03 11:11:11', 'YEAR') '01-JAN-03 00:00:00'
</p><p>trunc('22-AUG-03 11:11:11', 'MONTH') '01-AUG-03 00:00:00'
</p><p>trunc('22-AUG-03 11:11:11', 'DDD') '22-AUG-03 00:00:00'
</p><p>trunc(22-AUG-03 11:11:11', 'DAY') '17-AUG-03 00:00:00'
</p><p>Week 表示日期在这一年的第几个星期。 W表示日期在本月的第几个星期。 Start day of the week表示这个星期的第一天。 其他year，month，day，hour和minute分别是对应于标准格式yyyy-MM-dd HH:mm:ss。 本函数将时间年限范围设定为[1900, 9999]， 暂不支持公元前纪年，时间输入错误则返回null。
</p>
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="trunc.28_number.2C_.5B_decimal_places_.5D_.29"> trunc( number, [ decimal_places ] ) </span></h4>
</td><td> Returns a number truncated to a certain number of decimal_places.
<p>Number目前支持double和int，decimal_places必须为整数，如果没有decimal_places则默认去掉小数部分。 例如： trunc(125.815) would return 125
</p><p>trunc(125.815, 2) would return 125.81
</p><p>trunc(125.815, -2) would return 1E+2
</p><p>trunc(125, -2) would return 1E+2
</p><p>Number也可为整型，用法一致。 注：如出现trunc(125.815，20)的情况则会在125.815后面补充17个0。
</p>
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="months_between.28_date1.2C_date2_.29"> months_between( date1, date2 ) </span></h4>
</td><td> Returns the number of months between date1 and date2.
<p>If a fractional month is calculated, the function calculates the fraction based on a 31-day month. date格式为"yyyy-MM-dd"或者"yyyyMMdd"的字符串（字符串以这个格式开头即可，否则返回null）。 例如： months_between（‘2003-01-01’，‘2003-03-14’） return -2.41935483870968 如果两个日期位置交换则返回的是正值。 本函数将时间年限范围设定为[1900, 9999]， 暂不支持公元前纪年，时间输入错误则返回null。 注：输入如“2008-1-33”的情况不会报错，当作“2008-2-2”处理。
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="convert.28_string1_.2C_char_set_to_.2C_char_set_from.29"> convert( string1 , char_set_to , char_set_from) </span></h4>
</td><td>
<p>该函数目前不再使用，070以后版本中insert语句支持utf8和gbk之间的转换，只需要设置table的字符集属性。
</p>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="last_day.28date.29"> last_day(date) </span></h4>
</td><td> Returns the last day of the month extracted from the provided date value argument.
<p>date格式为"yyyy-MM-dd"的字符串(开头为该形式即可)，返回的值是1到31之间的值，如果输入不正确则返回NULL。yyyy-MM-dd 是事先约定的输入格式。 本函数将时间年限范围设定为[1900, 9999]， 暂不支持公元前纪年，时间输入错误则返回null。 注：输入如“2008-1-33”的情况不会报错，当作“2008-2-2”处理。
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="tz_offset.28_timezone_.29"> tz_offset( timezone ) </span></h4>
</td><td> Returns the time zone offset of a value.
<p>timezone can be a valid time zone name, a time zone offset from UTC, or the sessiontimezone function. "America/Los_Angeles" or "PST" or "-08:00" or "+08:00" or "GMT+8" or "GMT-07:00" ,type wrong input will return "+00:00". "08:00"is wrong, must like "+08:00".
</p>
</td></tr>
<tr>
<td> String
</td><td>
<h4> <span class="mw-headline" id="sessiontimezone.28.29"> sessiontimezone() </span></h4>
</td><td> 返回当前会话时区的时区值。
</td></tr>
<tr>
<td> byte
</td><td>
<h4> <span class="mw-headline" id="sign.28_number_.29"> sign( number ) </span></h4>
</td><td> Returns a value indicating the sign of a number.
<p>If number &lt; 0, then sign returns -1.If number = 0, then sign returns 0.If number &gt; 0, then sign returns 1. 如果输入的参数不符合标准则返回NULL。 目前支持byte，short，int，long，float和double。
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="chr.28_number_code_.29"> chr( number_code ) </span></h4>
</td><td> Returns the character based on the NUMBER code. number_code is the NUMBER code used to retrieve the character.
<p>该函数的输入范围为[0,127]，超出这个范围则会返回NULL，[0,32]范围内的结果是不可见的。
</p>
</td></tr>
<tr>
<td> boolean/byte/short/int
<p>/long/double/float/string
</p>
</td><td>
<h4> <span class="mw-headline" id="least.28_expr1.2C_expr2.2C_..._expr_n_.29"> least( expr1, expr2, ... expr_n ) </span></h4>
</td><td> Returns the smallest value in a list of expressions.
<p>expr1, expr2, . expr_n are expressions that are evaluated by the least function. Having a NULL value in one of the expressions will return NULL as the least value. 允许不同的数字类型double, float, bigint, int等的比较，但字符串只能与字符串做比较。 如果比较的是字符串，暂不支持转义符，如果字符串中含有"/"需要写成"//"。
</p>
</td></tr>
<tr>
<td> boolean/byte/short/int
<p>/long/double/float/string
</p>
</td><td>
<h4> <span class="mw-headline" id="greatest.28_expr1.2C_expr2.2C_..._expr_n_.29"> greatest( expr1, expr2, ... expr_n ) </span></h4>
</td><td> Returns the greatest value in a list of expressions.
<p>expr1, expr2, . expr_n are expressions that are evaluated by the greatest function. Having a NULL value in one of the expressions will return NULL as the greatest value. 允许不同的数字类型double, float, bigint, int等的比较，但字符串只能与字符串做比较。 如果比较的是字符串，暂不支持转义符，如果字符串中含有"/"需要写成"//"。
</p>
</td></tr>
<tr>
<td> boolean/byte/short/int
<p>/long/double/float/string
</p>
</td><td>
<h4> <span class="mw-headline" id="NVL.28expr1.2Cexpr2_.29"> NVL(expr1,expr2 ) </span></h4>
</td><td> 如果expr1为NULL,则返回expr2,否则返回expr1，其中expr1和expr2的类型必须一样。参数类型同返回值的类型一致。（若参数类型不一致，函数的行为不可预见，可能执行正确，可能执行失败）
</td></tr>
<tr>
<td> boolean/byte/short/int
<p>/long/double/float/string
</p>
</td><td>
<h4> <span class="mw-headline" id="NVL2.28expr1.2Cexpr2.2C_expr3.29"> NVL2(expr1,expr2, expr3) </span></h4>
</td><td> expr1为NULL，则返回expr3，否则返回expr2；其中expr1、expr2、expr3的类型要求一致（会做一定兼容，比如float和double，会隐式将float转成double，并不报错）。
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="SYSTIMESTAMP.28.29"> SYSTIMESTAMP() </span></h4>
</td><td> 返回当前的系统日期、时间（不支持时区）；输出时间格式为：yyyy-MM-dd hh24:mi:ss:ff3，当前仅支持24小时制。连续两次调用可能会在毫秒上有一点的偏差。
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="INSTR.28.28string.2Cstr.5B.2Cstart.5D.5B.2Cappear.5D.29"> INSTR((string,str[,start][,appear]) </span></h4>
</td><td> 返回string中str出现的位置。start代表开始搜索的位置，可选参数，默认为1（1表示第一个字符位置）；appear指示搜索第几次出现的，可选参数，默认为1；若没有匹配到，返回0。（start和appear取值为大于0的整数）
</td></tr>
<tr>
<td> int/long/float/double
</td><td>
<h4> <span class="mw-headline" id="MOD.28_n1.2C_n2_.29"> MOD( n1, n2 ) </span></h4>
</td><td> 返回一个n1除以n2的余数。支持的类型有Byte、Short、Integer、Long、Float、Double。返回值的正负和n1相关。使用此函数需要注意的2个问题：
<p>1、对小数执行mod计算可能会产生精度丢失，（如mod(3.1415926535897384626,3.1415926535897384627，返回结果为0.0)）此问题由java环境本身导致，若需要高精度的浮点计算，慎用此函数；
</p><p>2、传入比MAX_LONG还大的整数作为参数，则参数会被自动升级成Double类型，函数也可以正常计算结果，但返回的结果是小数类型。
</p>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="BITAND.28expr1.2C_expr2.29"> BITAND(expr1, expr2) </span></h4>
</td><td> 指定按位进行 AND 运算的两个数值。当前只支持Byte、Short、Integer、Long类型。如果 expr1和 expr2的位都是 1，相应的结果位就是 1;否则相应的结果位是 0。若expr1和expr2类型不一样，直接进行and计算
</td></tr>
<tr>
<td> String
</td><td>
<h4> <span class="mw-headline" id="NEXT_DAY.28date.2Cday.29"> NEXT_DAY(date,day) </span></h4>
</td><td> 计算给出日期date之后的下一个星期day的日期。day是数字， 1-7分别表示星期日-六；返回日期的格式为“YYYY-MM-DD”
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="TO_NUMBER.28string.29"> TO_NUMBER(string) </span></h4>
</td><td> 将给出的字符转换为数字；string必须为全数字串。（Oracle中的to_number很复杂，可变参数且支持多种类型。当前TDW中仅支持整数类型，包括short、int、long）
</td></tr>
<tr>
<td> String
</td><td>
<h4> <span class="mw-headline" id="TO_CHAR.28date.2Cformat.EF.BC.89"> TO_CHAR(date,format） </span></h4>
</td><td> 将日期data转化为一个字符串；date的格式固定为yyyy-mm-dd hh24:mi:ss:ff3，输出的格式由format指定。
<p>format当前支持的格式如下（不区分大小写）：
</p><p>yyyymmdd， 年月日；
</p><p>yyyymm，年月；
</p><p>mm，月
</p><p>dd，日
</p><p>yyyy-mm-dd
</p><p>yyyy-mm
</p><p>yyyymmddhh24miss，年月日时分秒（24小时制）
</p><p>yyyy-mm-dd hh24:mi:ss
</p><p>hh24miss
</p><p>yyyymmddhh24missff3，年月日时分秒毫秒（24小时制）
</p>
</td></tr>
<tr>
<td> String
</td><td>
<h4> <span class="mw-headline" id="TO_DATE.28date.EF.BC.8Cformat.29"> TO_DATE(date，format) </span></h4>
</td><td> 将字符串转化为一个日期；format指定了date的解析方式，支持的格式同 to_char。不支持默认的format，必须指定format。如果format不正确或者为空，则可能返回null或者执行出错。
</td></tr>
<tr>
<td> Boolean
</td><td>
<h4> <span class="mw-headline" id="expr_.5BNOT.5D_IN_.28expr1.5B.2C_expr2.2C....5D.29"> expr [NOT] IN (expr1[, expr2,...]) </span></h4>
</td><td> 该函数通常用于select、where和having语句中，用于检查表达式expr的值是否位于列表(expr1[, expr2,...])中，列表中各值的类型需要与expr的类型一致，允许列
<p>表中有NULL值。该函数与ORACLE中IN函数的区别在于，不允许列表中的表达式为子查询，列表为子查询的功能将由EXIST/NOT EXIST函数实现。
</p><p>关于IN/NOT IN中NULL值的处理（下面的说明中，用A、B指代任意非NULL值）：
</p><p>1. col IN（A,B,NULL）：如果col的值为NULL，则认为col符合IN的条件；
</p><p>2. col IN（A,B)：如果col的值为NULL，则认为col不符合IN的条件；
</p><p>3. col NOT IN（A,B,NULL）：如果col的值为NULL，则认为col不符合NOT IN的条件；
</p><p>4. col NOT IN（A,B）：如果col的值为NULL，则认为col符合NOT IN的条件。
</p><p>另，自100版本后，IN/NOT IN将支持expr、expr1等表达式的类型在int/bigint类型间的自动转换，用户不再需要使用cast进行强制类型转换。
</p><p><b>注意：where子句中分区字段使用in的话是不会做分区剪枝的，如果需要分区剪枝，建议替换成比较操作符。</b>
</p>
</td></tr>
<tr>
<td> Boolean
</td><td>
<h4> <span class="mw-headline" id=".5BNOT.5D_EXISTS_.28SELECT_..._FROM_..._WHERE_....29"> [NOT] EXISTS (SELECT ... FROM ... WHERE ...) </span></h4>
</td><td> 该函数用于WHERE语句中，自100版本后TDW支持在同一个WHERE语句中有两个或以上的EXISTS语句，但是，EXISTS/NOT EXISTS语句不允许位于OR和NOT表达式中。例如，NOT (EXISTS(...) AND ...)或 EXISTS(...) OR ...。EXISTS语句中的子查询而言，目前只允许使用SELECT、FROM、WHERE3个语句，如果涉及到更复杂的形式，请以更深层子查询的形式嵌套处理。EXISTS语句中的WHERE语句只能够允许有AND连接词，不可以包含OR连接词。另，EXISTS语句中的数据源不允许是JOIN数据源。
</td></tr>
<tr>
<td>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="wm_concat.28col1.5B.2Csplitstr.5B.2C.27desc.27.5B.2Ccol2.5D.5D.5D.29"> wm_concat(col1[,splitstr[,'desc'[,col2]]]) </span></h4>
</td><td> 将列col1的字段连接为一行，col1是需要concat的列名，必选参数；splitstr为连接字段之间的分隔符，可选参数，默认无分隔符；'desc'字段表示升序或者降序，只能取输入字符串'asc'（升序）或者'desc'（降序），可选字段，默认不排序；col2表示排序字段，按照这个字段进行排序对col1进行concat，可选字段，默认是col1字段本身。
<p>以表tbl（a,b,c）为例：
</p>
<pre>wm_concat(a)                  对a字段无分隔符不排序concat
wm_concat(a,'-')              对a字段使用'-'作为分隔符不排序concat
wm_concat(a,'-','asc')        对a字段使用'-'作为分隔符，按照a的升序concat
wm_concat(a,'-','desc')       对a字段使用'-'作为分隔符，按照a的降序concat
wm_concat(a,'-','asc',b)      对a字段使用'-'作为分隔符，按照b的升序concat
wm_concat(a,'-','desc',b)     对a字段使用'-'作为分隔符，按照b的降序concat
wm_concat(a,' ','asc',b)              对a字段以空格为分隔符，按照b的升序concat
wm_concat(distinct a,' ','asc')       对a字段去重以空格为分隔符，按照a的升序concat
wm_concat(distinct a,' ','asc',b)     结果可能存在一定的不确定性
</pre>
<p>注1：参数数目最多为4最少为1，参数的位置严格定义：第一个参数表示合并字段，第二个参数表示分隔符，第三个字段表示升降序，第四个字段表示排序字段。如果需要使用后面的参数，则前面的参数也必须列出，例如第二个参数，即使不想使用分隔符，在需要第三个参数的时候第二个参数也必须以' '的形式列出。
</p><p>注2：a字段可以带Distinct操作，可以以a字段本身进行升序或者降序排序。如果带有另外一个排序字段b，处理策略是，首先对a进行Distinct操作，然后按照b字段排序进行连接，这里面有一个问题，如下面的例子所示：
</p><p>表tbl
</p><p>a b
</p><p>1 3
</p><p>1 10
</p><p>2 5
</p><p>Select wm_concat(distinct a,<i>,'asc',b) from tbl;</i> a=1的记录有两行，在进行Distinct操作的时候会只保留一行，因为记录的输入顺序不定，所以这样的情况下可能导致输出结果不一样。 如果保留了第一行，则输出结果是：12，如果保留了第二行的话则输出结果是21。
</p><p>注3：连接字段可以为任意类型，但是输出均为string类型，并且输出的string字段长度不能超过32KB，否则报错。
</p><p>注4：分隔符字段理论上可以使用任意字符，但是换行符和回车符除外。
</p>
</td></tr>
<tr>
<td>
</td></tr>
<tr>
<td> boolean/byte/short/int
<p>/long/double/float/string
</p>
</td><td>
<h4> <span class="mw-headline" id="decode.28expression_.2C_search_.2C_result_.5B.2C_search_.2C_result.5D..._.5B.2C_default.5D.29"> decode(expression , search , result [, search , result]... [, default]) </span></h4>
</td><td> decode函数与一系列嵌套的IF-THEN-ELSE语句相似。expression与search等依次进行比较。如果expression和第i个search项匹配，就返回第i个对应的result。如果expression与任何的search值都不匹配，则返回default。如果default没有，则返回null。该函数参数是变长的，最少3个参数，最多255个参数。所有的result和default需要保持类型一致，expression与所有的search也需要保持类型一致（这两组参数支持int和bigint类型混合使用，混合情况下返回值类型为bigint），参数类型由expression和第一个result所决定。expression和第一个result输入不可以为null（表字段不受该限制）。如果比较的是字符串，暂不支持转义符。示例：SELECT decode(supplier_id,10000,'IBM',10001,'Microsoft',10002,'Hewlett Packard','Gateway') FROM suppliers;
<p><b>注</b>：<b>在decode函数中null和null比较是不会匹配的，这点可能和oracle不一样，如有疑问可以联系michealxu</b>。
</p>
</td></tr>
<tr>
<td>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="a_.7C.7C_b_.E4.BD.9C.E4.B8.BAconcat.E5.87.BD.E6.95.B0.E7.9A.84.E7.AE.80.E5.8C.96"> a &#124;&#124; b 作为concat函数的简化 </span></h4>
</td><td> [R100版本开始支持] 使用select a || b from tbl 来替代 select concat(a,b) from tbl 来简化字符串连接操作。||可以看做一个运算符，其优先级别和+,-相同
<p><br />
</p>
</td></tr>
<tr>
<td> byte/short/int/long/float/double/string
</td><td>
<h4> <span class="mw-headline" id="between"> between </span></h4>
</td><td>
<p>a between b and c 等同于 a&gt;=b and a&lt;=c，但该函数暂不支持bool类型，如果a,b,c中含有null则该次比较结果为false。
</p><p><b>注意</b>：between目前还不支持分区剪枝，也就是说对于分区列使用between，仍然会扫描全部分区。目前分区剪枝只支持 =，&gt;,&lt;,&lt;=,&gt;=这些简单的操作符，未来TDW版本是否支持between以及其他函数的分区剪枝还不确定，所以最保险的办法是对分区列使用上面的简单操作符
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="numformat"> numformat </span></h4>
</td><td>
<p>numformat(a)将double类型数据a转成字符串，如果a是科学计数法则将其转成原始记法。 numformat(a,b,c,d,e)b表示小数位的最大保留位数，c表示小数位的最小保留位数，d表示整数位的最大保留位数，e表示整数位的最小保留位数 <b>注意</b>：该函数主要给不需要科学计数法的用户使用，而且<b>保留的最大位数一定要大于保留的最小位数，值为非负</b>。
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="commonStr.28string.2Cstring.2Cstring.29"> commonStr(string,string,string) </span></h4>
</td><td>
<p>commonStr(col1,col2,separator): col1和col2为使用separator指定的分隔符连接的字符串，separator为分隔符，该函数找出col1和col2中使用分隔符隔开的相同的单词，并返回使用分隔符连接这些相同单词的字符串。 col1 and col2 必须是字符串类型, col1 and col2 必须使用相同的分隔符。 当col1和col2没有相同字符串时，返回空字符串“”。 当col1和col2有一个为null时，返回null。 函数对分隔符没有限制！ 例如:
</p>
<pre>  &gt; SELECT commonStr('a,b,c,d','d,c',',') FROM src LIMIT 1;
d,c
&gt; SELECT commonStr(' ab,bc,ac','ac,bc',',') FROM src LIMIT 1;
ac,bc
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="md5.28long.2Fdouble.2Fint.2Fstring.2Clong.2Fdouble.2Fint.2Fstring.29"> md5(long/double/int/string,long/double/int/string) </span></h4>
</td><td>
<p>md5(col1,col2): col1和col2为列名或者常量，支持long/double/int/string类型，该函数把col1和col2作为字符串连接在一起进行md5加密处理，返回加密后的二进制字符串。 例如:
</p>
<pre>  &gt; SELECT md5(11,2),md5(1,'12'),md5('1','1.2'),md5(1,1.2);
  7f6ffaa6bb0b408017b62254211691b5
  7f6ffaa6bb0b408017b62254211691b5
  17d49ab14f0d4a8bbffe14ad3d6b7b13
  17d49ab14f0d4a8bbffe14ad3d6b7b13
</pre>
</td></tr></table>
<h4> <span class="mw-headline" id=".E7.89.B9.E5.88.AB.E8.AF.B4.E6.98.8E"> <b>特别说明</b> </span></h4>
<p>TDW中所有关于日期处理函数中date格式的约定：
</p><p>a、类似如yyyy-mm-dd hh24:mi:ss:ff3的格式中，严格遵循4位数字表示年，2位数字表示月，2为数字表示日等等
</p><p>b、对于需要返回date类型的函数（如to_date），系统对输入的字符串执行弱校验，同hive保持一致，如能将用户输入的”2010-01-32”正确转换成”2010-02-01”；
</p><p>c、对于输入date类型的函数（如to_char），系统对输入的date合法性不执行检查，若用户输入的date为不合法的“2010-01-32”则返回的字符串依旧为“2010-01-32”。
</p><p>d、另外，各个时间处理函数中，只关心需要的精度，若精度不够，则会执行失败；否则忽略多余的精度。 如next_day中只关心到yyyy-mm-dd，而忽略所有的hh24:mi:ss:ff3信息。
</p><p>e、在没有指定format的时候，缺省使用yyyy-mm-dd hh24:mi:ss:ff3。
</p>
<h3> <span class="mw-headline" id=".E9.AB.98.E7.BA.A7.E5.88.86.E6.9E.90.E5.87.BD.E6.95.B0"> 高级分析函数 </span></h3>
<table border="1">

<tr>
<td> 返回值
</td><td> 函数名
</td><td> 说明
</td></tr>
<tr>
<td> 返回类型取决于value_expr的类型
</td><td>
<h4> <span class="mw-headline" id="LAG_.28_value_expr_.5B.2C_offset_.5D_.5B.2C_default.5D_.29OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"> LAG ( value_expr [, offset ] [, default] )OVER ( [query_partition_clause] order_by_clause ) </span></h4>
</td><td> 通过该函数，可以不通过自连接同时去访问结果集中的其它行，它允许你像处理数组一样的去处理游标。给定一个查询结果集和游标的位置，就可以访问与当前行一起选择的以前的行。其相反的函数是LEAD。
<p>1.offset是一个正整数，在用户没有设置的情况下其默认值为1，表示当前行的前面一行，若索引超出窗口的范围，就返回default值;
</p><p>2.在用户没有设置default值的情况下，缺省默认返回NULL，用户可以根据所处理列的类型自行设定默认值。例如，如果该列为整型，则可以将默认值设为整数或NULL;
</p><p>3.如果为浮点型，则可以将默认值设为浮点数或NULL；如果为字符串类型，则可以将默认值设为用单引号或双引号标识的字符串常量或NULL；如果是布尔型，则可以设为布尔值或NULL。
</p>
</td></tr>
<tr>
<td> 返回类型取决于value_expr的类型
</td><td>
<h4> <span class="mw-headline" id="LEAD_.28value_expr_.5B.2C_offset_.5D_.5B.2C_default_.5D_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"> LEAD (value_expr [, offset ] [, default ] ) OVER ( [query_partition_clause] order_by_clause ) </span></h4>
</td><td> 含义与LAG相反，只是它返回的是当前行的后面的行，其余部分和LAG函数一模一样。
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="RANK_.28_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"> RANK ( ) OVER ( [query_partition_clause] order_by_clause ) </span></h4>
</td><td> 1.此函数没有参数，可以计算数据项在分区中的排名。在每个分区内，根据ORDER BY子句中表达式的值，计算查询返回的每一行与其它行的相对位置。组内的数据按ORDER BY子句排序，然后给每一行赋一个号，从而形成一个序列，该序列从1开始，往后累加，有同样值的行得到同样的数字序号（认为NULL是相等的）。每次ORDER BY表达式的值发生变化时，该序列也随之增加。然而，如果两行得到同样的排序，则序数将随后跳跃，如两行序数为1，则没有序数
<p>2.序列将给组中的下一行分配值3，DENSE_RANK则没有任何跳跃，这也是它与DENSE_RANK的唯一区别
</p><p>3.默认情况下，RANK()和DENSE_RANK()在递增排序中将空值指定为最低序号1，在递减排序中将空值指定为最高序号
</p>
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="DENSE_RANK_.28_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"> DENSE_RANK ( ) OVER ( [query_partition_clause] order_by_clause ) </span></h4>
</td><td> 1.此函数没有参数，在每个分区内，根据ORDER BY子句中表达式的值，计算查询返回的每一行与其它行的相对位置。组内的数据按ORDER BY子句排序，然后给每一行赋一个号，从而形成一个序列，该序列从1开始，往后累加，有同样值的行得到同样的数字序号（认为NULL是相等的）。每次ORDER BY表达式的值发生变化时，该序号也随之增加，序号返回的时没有间隔的数。
<p>2.RANK和DENSE_RANK的区别在于处理相等数据项的方法;RANK()在出现等级相同的元素时就将排名中的位置留出来，而DENSE_RANK()则不是。
</p>
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="ROW_NUMBER_.28_.29_OVER_.28_.5Bquery_partition_clause.5D_order_by_clause_.29"> ROW_NUMBER ( ) OVER ( [query_partition_clause] order_by_clause ) </span></h4>
</td><td> 返回每个分区内按照某些表达式排序后的行号，从1开始，为每条分组记录返回一个数字。NULL值被视为最小值。
</td></tr>
<tr>
<td> Bigint或double，具体返回类型取决于value_expr的类型
</td><td>
<h4> <span class="mw-headline" id="SUM_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause_.5D_.29"> SUM ( [ DISTINCT ] expr )OVER ( [query_partition_clause] [order_by_clause ] ) </span></h4>
</td><td> 1.该函数计算组中表达式的累积和；如果带有distinct，则返回的是该列中不同的值的总和。
<p>2.OVER子句中最多只能有分区子句。
</p><p>（3.如果应用中需要用到OVER子句为空的SQL语句，则可以通过使用聚集函数SUM来改写SQL实现一样的功能。）100版本后取消该限制。
</p>
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="COUNT.28_1_.7C_.5B_DISTINCT_.5D_expr.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"> COUNT( 1 &#124; [ DISTINCT ] expr)OVER ( [query_partition_clause] [order_by_clause] ) </span></h4>
</td><td> 1.用于计算一个查询返回的行数。如果参数是“1”，那么它返回所有行的总数，目前，count（1）仅限带query_partition_clause的情况下使用；如果参数是某个列，那么，它返回这个列的值非NULL的行的总数；如果带有distinct，则返回的是该列中不同值的数目。
<p>2.OVER子句中最多只能有分区子句。（如果应用中需要用到OVER子句为空的SQL语句，则可以通过使用聚集函数COUNT来改写SQL实现一样的功能。）100版本后取消该限制。
</p>
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="AVG_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"> AVG ( [ DISTINCT ] expr )OVER ([query_partition_clause] [order_by_clause] ) </span></h4>
</td><td> 1.用于计算平均值；如果带有distinct，则返回的是该列中不同的值的平均数。
<p>2.OVER子句中最多只能有分区子句。（如果应用中需要用到OVER子句为空的SQL语句，则可以通过使用聚集函数AVG来改写SQL实现一样的功能。）100版本后取消该限制。
</p>
</td></tr>
<tr>
<td> 返回类型取决于expr的类型
</td><td>
<h4> <span class="mw-headline" id="MAX_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"> MAX ( [ DISTINCT ] expr )OVER ( [query_partition_clause] [order_by_clause] ) </span></h4>
</td><td> 1.在一个分区中查找表达式的最大值；如果带有distinct，则返回的是该列中不同值的最大值。
<p>2.OVER子句中最多只能有分区子句。（如果应用中需要用到OVER子句为空的SQL语句，则可以通过使用聚集函数MAX来改写SQL实现一样的功能。）100版本后取消该限制。
</p>
</td></tr>
<tr>
<td> 返回类型取决于expr的类型
</td><td>
<h4> <span class="mw-headline" id="MIN_.28_.5B_DISTINCT_.5D_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"> MIN ( [ DISTINCT ] expr )OVER ( [query_partition_clause] [order_by_clause] ) </span></h4>
</td><td> 1.在一个分区中查找表达式的最小值；如果带有distinct，则返回的是该列中不同值的最小值。
<p>2.OVER子句中最多只能有分区子句。（如果应用中需要用到OVER子句为空的SQL语句，则可以通过使用聚集函数MIN来改写SQL实现一样的功能。）100版本后取消该限制。
</p>
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="RATIO_TO_REPORT_.28_expr_.29OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"> RATIO_TO_REPORT ( expr )OVER ( [query_partition_clause] [order_by_clause] ) </span></h4>
</td><td> 1.用来计算某个值在一组值的总和中所占的比率。
<p>2.OVER子句中最多只能有分区子句。（如果OVER语句中没有分区子句，则该分析函数的实现方法与SUM类似，完全可以通过改写SQL实现该功能。改写的具体做法是使用一个SQL计算出某一列的总和，然后，用每行中要计算该分析函数的那列值来除该总和即可。）100版本后取消该限制。
</p>
</td></tr>
<tr>
<td> 返回类型取决于expr的类型
</td><td>
<h4> <span class="mw-headline" id="FIRST_VALUE_.28_expr_.29_OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"> FIRST_VALUE ( expr ) OVER ( [query_partition_clause] [order_by_clause] ) </span></h4>
</td><td> 1.用来计算一组值的第一个值
<p>2.order子句必须包含
</p>
</td></tr>
<tr>
<td> 返回类型取决于expr的类型
</td><td>
<h4> <span class="mw-headline" id="LAST_VALUE_.28_expr_.29_OVER_.28_.5Bquery_partition_clause.5D_.5Border_by_clause.5D_.29"> LAST_VALUE ( expr ) OVER ( [query_partition_clause] [order_by_clause] ) </span></h4>
</td><td> 1.用来计算一组值的最后一个值
<p>2.order子句必须包含
</p>
</td></tr></table>
<h4> <span class="mw-headline" id=".E7.89.B9.E5.88.AB.E8.AF.B4.E6.98.8E_2"> <b>特别说明</b> </span></h4>
<p>在上表中，用方括号括起来的部分是可选项。 在上表中用到的分区子句query_partition_clause和分区排序子句order_by_clause定义如下：
</p><p><i>Query_Partition_Clause</i>
</p><p>分区子句的语法是：
</p>
<pre>PARTITION BY (exp1[,exp2,...expN])
</pre>
<p>分区子句是在逻辑上对前面计算返回的记录集，即经过FROM/WHERE/GROUP BY/JOINS“筛选”后的结果集，按照exp1[,exp2,...expN]进行分组。其实，这里就和SELECT中的GROUP BY子句的功能有些类似，就是按照某些列对结果集分组。因此，在这里，单词“patition”和“group”是同义词。分析函数被独立作用于每个分组，并在每个分组上被重置。由于涉及到计算效率和任务成败，TDW要求所有的分析函数必须包含分区子句。
</p><p><i>Order_By_Clause</i>
</p>
<pre>  分区排序子句的作用是指定一个数据分区内，数据记录是如何排序的。你可以指定多个列来指定排序。该子句功能有点类似SELECT中的ORDER BY子句。在用户没有指定的情况下默认为增序排列。
</pre>
<p>分区排序子句的语法如下：
</p>
<pre> ORDER BY expr [ DESC | ASC ]
         [,expr [ DESC | ASC ]
         ]...
</pre>
<p><br />
</p>
<h4> <span class="mw-headline" id=".E9.99.90.E5.AE.9A"> <b>限定</b> </span></h4>
<p>根据应用的需求和实现难度，对同一个SELECT子句中出现的分析函数，我们有如下限定条件。由于分析函数是无损的，对数据分析完成后，数据行数不变，因此，以下限制不会对应用产生太大影响，应用基本可以通过改写SQL实现与ORACLE类似的功能：
</p><p>分组函数（聚合函数）与分析函数不可以同时存在。比如，SUM(COUNT(col)) OVER(...)之类的语句，可以通过改写SQL，先进行分组聚合分析，然后使用分析函数。例如：
</p>
<pre>SELECT 
Month, prd_type_id,
SUM(SUM(amount)) OVER (PARTITION BY month) AS total_month_amount,
SUM(SUM(amount)) OVER (PARTITION BY prd_type_id) AS total_product_type_amount
FROM all_sales
GROUP BY month, prd_type_id
</pre>
<p>上面这个例子融合了限制条件1和限制条件2，可以改写为如下的SQL语句：
</p>
<pre>SELECT b.month, b.prd_type_id,
  b.total_month_amount,
  SUM(b.sum_month_prd) OVER (PARTITION BY prd_type_id) AS total_product_type_amount,
FROM
（SELECT a.month, a.prd_type_id, a.sum_month_prd,
    SUM(a.sum_month_prd) OVER (PARTITION BY month) AS total_month_amount
    FROM （
           SELECT 
           Month, prd_type_id,
           SUM(amount) AS sum_month_prd,
           FROM all_sales
           GROUP BY month, prd_type_id
          ）  a
） b
</pre>
<p>如果某个分析函数中含有distinct，那么，该SQL子句中的所有分析函数不可以含有分组排序语句。通过分析现有代码发现，没有语句不符合这个限制条件，如果未来有需求，则可以改写，将含有distinct的语句单独处理。
</p>
<pre>SELECT 
field1, field2, field3,
COUNT(distinct field1) OVER (PARTITION BY field2) as field4,
SUM(field3) OVER (PARTITION BY field2 ORDER BY field1) AS field5
FROM table1
</pre>
<p>可以用如下SQL改写：
</p>
<pre>SELECT
a.field1, a.field2, a.field3, a.field4,
SUM(a.field3) OVER (PARTITION BY a.field2 ORDER BY a.field1) AS field5
FROM (
SELECT 
field1, field2, field3,
COUNT(distinct field1) OVER (PARTITION BY field2) as field4,
FROM table1 )  a
</pre>
<p>与限制条件2的原因相同，TDW将不支持分析函数对不同列的multi-distinct功能，可以通过改写SQL实现同样的功能。但是，如果multi-distinct针对的列相同，则可以执行。也就是说，下面这语句可以执行：
</p>
<pre>SELECT 
field1, field2, field3,
COUNT(distinct field1) OVER (PARTITION BY field2) as field4,
SUM(distinct field1) OVER (PARTITION BY field2) AS field5
FROM table1
</pre>
<p>而这个语句只能改写：
</p>
<pre>SELECT 
field1, field2, field3,
COUNT(distinct field1) OVER (PARTITION BY field2) as field4,
COUNT(distinct field3) OVER (PARTITION BY field2) AS field5
FROM table1
</pre>
<p>可以用如下SQL改写：
</p>
<pre>SELECT
a.field1, a.field2, a.field3, a.field4,
COUNT( distinct a.field3) OVER (PARTITION BY a.field2) AS field5
FROM (
SELECT 
field1, field2, field3,
COUNT(distinct field1) OVER (PARTITION BY field2) as field4,
FROM table1 )  a
</pre>
<p>如果多个分析函数中含有分区子句和分区排序子句，那么这些分析函数中的分区子句和分区排序子句必须相同，否则，将该语句分拆成多个SQL语句。具体示例同限制一。
</p><p>(分析函数中必须包含分区子句，否则，通过PL和改写SQL实现。)自100版本起，该限制取消，允许用户进行全局分析。但是，如果过于对过大的数据集进行全局分析，可能导致运算速度过慢等问题。
</p><p>分析函数与select distinct冲突。例如，
</p>
<pre>From table1
Select distinct a, b, count(c) over(partition by d)
</pre>
<p>类似上述这种形式是不允许的。
</p>
<h2> <span class="mw-headline" id="HIVE.E5.86.85.E7.BD.AE.E6.93.8D.E4.BD.9C.E7.AC.A6"> HIVE内置操作符 </span></h2>
<h3> <span class="mw-headline" id=".E5.85.B3.E7.B3.BB.E6.93.8D.E4.BD.9C.E7.AC.A6"> 关系操作符 </span></h3>
<p>比较两个操作参数，返回 TRUE或者FALSE。
</p>
<table border="1">

<tr>
<td> <b>Operator</b>
</td><td> <b>Operand types</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3D_B"> A = B </span></h4>
</td><td>
<p>All primitive types
</p>
</td><td> TRUE if expression A is equal to expression B otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3D.3D_B"> A == B </span></h4>
</td><td>
<p>None!
</p>
</td><td> Fails because of invalid syntax. SQL uses =, not ==
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3C.3E_B"> A &lt;&gt; B </span></h4>
</td><td>
<p>All primitive types
</p>
</td><td> NULL if A or B is NULL, TRUE if expression A is NOT equal to expression B otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3C_B"> A &lt; B </span></h4>
</td><td>
<p>All primitive types
</p>
</td><td> NULL if A or B is NULL, TRUE if expression A is less than expression B otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3C.3D_B"> A &lt;= B </span></h4>
</td><td>
<p>All primitive types
</p>
</td><td> NULL if A or B is NULL, TRUE if expression A is less than or equal to expression B otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3E_B"> A &gt; B </span></h4>
</td><td>
<p>All primitive types
</p>
</td><td> NULL if A or B is NULL, TRUE if expression A is greater than expression B otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3E.3D_B"> A &gt;= B </span></h4>
</td><td>
<p>All primitive types
</p>
</td><td> NULL if A or B is NULL, TRUE if expression A is greater than or equal to expression B otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_IS_NULL"> A IS NULL </span></h4>
</td><td>
<p>All types
</p>
</td><td> TRUE if expression A evaluates to NULL otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_IS_NOT_NULL"> A IS NOT NULL </span></h4>
</td><td>
<p>All types
</p>
</td><td> TRUE if expression A not evaluates to NULL otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_LIKE_B"> A LIKE B </span></h4>
</td><td>
<p>strings
</p>
</td><td> NULL if A or B is NULL, TRUE if string A matches the SQL simple regular expression B, otherwise FALSE. The comparison is done character by character. The _ character in B matches any character in A(similar to . in posix regular expressions) while the&nbsp;% character in B matches an arbitrary number of characters in A(similar to .* in posix regular expressions). e.g.
<pre>'foobar' like 'foo' evaluates to FALSE where as 'foobar' like 'foo_ _ _' evaluates to TRUE and so does 'foobar' like 'foo%'
</pre>
<p>允许用户使用 A NOT LIKE B这种形式。
</p>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_RLIKE_B"> A RLIKE B </span></h4>
</td><td>
<p>strings
</p>
</td><td> NULL if A or B is NULL, TRUE if string A matches the Java regular expression B(See Java regular expressions syntax), otherwise FALSE. e.g.
<pre>'foobar' rlike 'foo' evaluates to FALSE where as 'foobar' rlike '^f.*r$' evaluates to TRUE
</pre>
<p>允许用户使用 A NOT RLIKE B这种形式。
</p>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_REGEXP_B"> A REGEXP B </span></h4>
</td><td>
<p>strings
</p>
</td><td> Same as RLIKE
</td></tr></table>
<h3> <span class="mw-headline" id=".E7.AE.97.E6.95.B0.E6.93.8D.E4.BD.9C.E7.AC.A6"> 算数操作符 </span></h3>
<p>对操作参数进行相应的计算，结果为数字类型。如果操作参数之一为NULL，则操作结果也为NULL
</p>
<table border="1">

<tr>
<td> <b>Operator</b>
</td><td> <b>Operand types</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.2B_B"> A + B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the result of adding A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands. e.g. since every integer is a float, therefore float is a containing type of integer so the + operator on a float and an int will result in a float.
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_-_B"> A - B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the result of subtracting B from A. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.2A_B"> A * B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the result of multiplying A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands. Note that if the multiplication causing overflow, you will have to cast one of the operators to a type higher in the type hierarchy.
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.2F_B"> A / B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the result of dividing B from A. The result is a double type.
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A.C2.A0.25_B"> A&nbsp;% B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the reminder resulting from dividing A by B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
<p>%符号的前后需要加空格使用。
</p>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.26_B"> A &amp; B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the result of bitwise AND of A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.7C_B"> A &#124; B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the result of bitwise OR of A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.5E_B"> A ^ B </span></h4>
</td><td>
<p>All number types
</p>
</td><td> Gives the result of bitwise XOR of A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id=".7EA"> ~A </span></h4>
</td><td>
<p>All number types
</p>
</td><td>
<p>Gives the result of bitwise NOT of A. The type of the result is the same as the type of A.
</p>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3C.3C_B"> A &lt;&lt; B </span></h4>
</td><td>
<p>支持tinyint、smallint、int和bigint类型，不支持double和float类型
</p>
</td><td>
<p>二进制位左移函数，语法同java，对运算符右侧的参数进行模32运算（左侧参数为bigint类型时模64）
</p>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.3E.3E_B"> A &gt;&gt; B </span></h4>
</td><td>
<p>支持tinyint、smallint、int和bigint类型，不支持double和float类型
</p>
</td><td>
<p>二进制位右移函数，语法同java，对运算符右侧的参数进行模32运算（左侧参数为bigint类型时模64）
</p>
</td></tr></table>
<h3> <span class="mw-headline" id=".E9.80.BB.E8.BE.91.E6.93.8D.E4.BD.9C.E7.AC.A6"> 逻辑操作符 </span></h3>
<p>对参数进行逻辑运算，返回值可能是TRUE，FALSE或者NULL。当操作参数至少有一个NULL时，结果为NULL。
</p>
<table border="1">

<tr>
<td> <b>Operator</b>
</td><td> <b>Operand types</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_AND_B"> A AND B </span></h4>
</td><td>
<p>boolean
</p>
</td><td> TRUE if both A and B are TRUE, otherwise FALSE. NULL if A or B is NULL
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_.26.26_B"> A &amp;&amp; B </span></h4>
</td><td>
<p>boolean
</p>
</td><td> Same as A AND B
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="A_OR_B"> A OR B </span></h4>
</td><td>
<p>boolean
</p>
</td><td> TRUE if either A or B or both are TRUE; FALSE OR NULL is NULL; otherwise FALSE
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id="NOT_A"> NOT A </span></h4>
</td><td>
<p>boolean
</p>
</td><td> TRUE if A is FALSE or NULL if A is NULL. Otherwise FALSE.
<p>（形如：not not true形式的表达式暂不支持，提供的变通方法是用括号逐层括起，即这里使用not (not true)即可完成相同的功能。）
</p>
</td></tr>
<tr>
<td>
<h4> <span class="mw-headline" id=".C2.A0.21A"> &nbsp;!A </span></h4>
</td><td> boolean
</td><td> Same as NOT A （!操作符已支持，语法与NOT相同）
</td></tr></table>
<h2> <span class="mw-headline" id="HIVE.E5.86.85.E7.BD.AE.E5.87.BD.E6.95.B0"> HIVE内置函数 </span></h2>
<h3> <span class="mw-headline" id=".E6.95.B0.E5.AD.A6.E5.87.BD.E6.95.B0"> 数学函数 </span></h3>
<p>下面是常见的数学函数，大多数函数在输入为NULL时，返回值也是NULL。
</p>
<table border="1">

<tr>
<td> <b>Return Type</b>
</td><td> <b>Name(Signature)</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td> BIGINT
</td><td>
<h4> <span class="mw-headline" id="round.28double_a.29"> round(double a) </span></h4>
</td><td> Returns the rounded BIGINT value of the double
</td></tr>
<tr>
<td> BIGINT
</td><td>
<h4> <span class="mw-headline" id="floor.28double_a.29"> floor(double a) </span></h4>
</td><td> Returns the maximum BIGINT value that is equal or less than the double
</td></tr>
<tr>
<td> BIGINT
</td><td>
<h4> <span class="mw-headline" id="ceil.28double_a.29.2Cceiling.28double_a.29"> ceil(double a),ceiling(double a) </span></h4>
</td><td> Returns the minimum BIGINT value that is equal or greater than the double
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="rand.28.29.2Crand.28int_seed.29"> rand(),rand(int seed) </span></h4>
</td><td> Returns a random number (that changes from row to row) that is distributed uniformly from 0 to 1. Specifiying the seed will make sure the generated random number sequence is deterministic.
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="exp.28double_a.29"> exp(double a) </span></h4>
</td><td> Returns e^a where e is the base of the natural logarithm
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="ln.28double_a.29"> ln(double a) </span></h4>
</td><td> Returns the natural logarithm of the argument
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="log10.28double_a.29"> log10(double a) </span></h4>
</td><td> Returns the base-10 logarithm of the argument
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="log2.28double_a.29"> log2(double a) </span></h4>
</td><td> Returns the base-2 logarithm of the argument
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="log.28double_base.2Cdouble_a.29"> log(double base,double a) </span></h4>
</td><td> Return the base "base" logarithm of the argument
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="pow.28double_a.2Cdouble_p.29.2Cpower.28double_a.2Cdouble_p.29"> pow(double a,double p),power(double a,double p) </span></h4>
</td><td> Return a^p
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="sqrt.28double_a.29"> sqrt(double a) </span></h4>
</td><td> Returns the square root of a
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="bin.28BIGINT_a.29"> bin(BIGINT a) </span></h4>
</td><td> Returns the number in binary format (see <a href="http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_bin" class="external autonumber" rel="nofollow">[1]</a>)
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="hex.28BIGINT_a.29.2Chex.28string_a.29"> hex(BIGINT a),hex(string a) </span></h4>
</td><td> If the argument is an int, hex returns the number as a string in hex format. Otherwise if the number is a string, it converts each character into its hex representation and returns the resulting string. (see <a href="http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_hex" class="external autonumber" rel="nofollow">[2]</a>)
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="unhex.28string_a.29"> unhex(string a) </span></h4>
</td><td> Inverse of hex. Interprets each pair of characters as a hexidecimal number and converts to the character represented by the number.
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="conv.28BIGINT_num.2Cint_from_base.2Cint_to_base.29"> conv(BIGINT num,int from_base,int to_base) </span></h4>
</td><td> Converts a number from a given base to another (see <a href="http://dev.mysql.com/doc/refman/5.0/en/mathematical-functions.html#function_conv" class="external autonumber" rel="nofollow">[3]</a>)
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="abs.28double_a.29"> abs(double a) </span></h4>
</td><td> Returns the absolute value
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="pmod.28int_a.2Cint_b.29.2Cpmod.28double_a.2Cdouble_b.29"> pmod(int a,int b),pmod(double a,double b) </span></h4>
</td><td> Returns the positive value of a mod b
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="sin.28double_a.29"> sin(double a) </span></h4>
</td><td> Returns the sine of a (a is in radians)
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="asin.28double_a.29"> asin(double a) </span></h4>
</td><td> Returns the arc sin of x if -1&lt;=a&lt;=1 or null otherwise
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="cos.28double_a.29"> cos(double a) </span></h4>
</td><td> Returns the cosine of a (a is in radians)
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="acos.28double_a.29"> acos(double a) </span></h4>
</td><td> Returns the arc cosine of x if -1&lt;=a&lt;=1 or null otherwise
</td></tr>
<tr>
<td> int double
</td><td>
<h4> <span class="mw-headline" id="positive.28int_a.29.2Cpositive.28double_a.29"> positive(int a),positive(double a) </span></h4>
</td><td> Returns a
</td></tr>
<tr>
<td> int double
</td><td>
<h4> <span class="mw-headline" id="negative.28int_a.29.2Cnegative.28double_a.29"> negative(int a),negative(double a) </span></h4>
</td><td> Returns -a
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="percentile.28BIGINT_col.2C_p.29"> percentile(BIGINT col, p) </span></h4>
</td><td> 求准确的第pth个百分位数，p必须介于0和1之间，但是col字段目前只支持长整数，不支持浮点数类型
<p>语法: percentile(BIGINT col, p)
</p><p>返回值: double
</p><p>select percentile(CAST (key AS BIGINT),0.5) from cherry
</p><p>select percentile(CAST (key AS BIGINT),ARRAY(0.5,0.5)) from cherry
</p>
</td></tr></table>
<h3> <span class="mw-headline" id=".E7.B1.BB.E5.9E.8B.E8.BD.AC.E6.8D.A2.E5.87.BD.E6.95.B0"> 类型转换函数 </span></h3>
<table border="1">

<tr>
<td> <b>Return Type</b>
</td><td> <b>Name(Signature)</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td> Expected "=" to follow "type"
</td><td>
<h4> <span class="mw-headline" id="cast.28expr_as_.3Ctype.3E.29"> cast(expr as &lt;type&gt;) </span></h4>
</td><td> Converts the results of the expression expr to &lt;type&gt; e.g. cast('1' as BIGINT) will convert the string '1' to it integral representation. A null is returned if the conversion does not succeed.
</td></tr></table>
<h3> <span class="mw-headline" id=".E6.97.B6.E9.97.B4.E5.87.BD.E6.95.B0"> 时间函数 </span></h3>
<table border="1">

<tr>
<td> <b>Return Type</b>
</td><td> <b>Name(Signature)</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="from_unixtime.28int_unixtime_.5B.2C_pattern.5D.29"> from_unixtime(int unixtime [, pattern]) </span></h4>
</td><td> Converts the number of seconds from unix epoch (1970-01-01 00:00:00 UTC) to a string representing the timestamp of that moment in the current system time zone in the format of "1970-01-01 00:00:00"
<p>注意：该函数的参数unixtime是秒数。 该函数在120版本后支持bigint类型的参数，返回日期的范围为9999-12-31 23:59:59和0001-01-01 00:00:00之间。 <b>注意：pattern的默认值是yyyy-MM-dd HH:mm:ss，其中月份MM一定要大写。</b>
</p>
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="unix_timestamp.28.29"> unix_timestamp() </span></h4>
</td><td> Gets current time stamp using the default time zone.
<p>注意：该函数返回的是秒数。
</p>
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="unix_timestamp.28string_date_.5B.2C_pattern.5D.29"> unix_timestamp(string date [, pattern]) </span></h4>
</td><td> Converts time string in format yyyy-MM-dd HH:mm:ss to Unix time stamp, return 0 if fail: unix_timestamp('2009-03-20 11:30:01') = 1237573801
<p>注意：该函数返回的是秒数。
</p>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="year.28string_date.29"> year(string date) </span></h4>
</td><td> Returns the year part of a date or a timestamp string: year("1970-01-01 00:00:00") = 1970, year("1970-01-01") = 1970
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="month.28string_date.29"> month(string date) </span></h4>
</td><td> Returns the month part of a date or a timestamp string: month("1970-11-01 00:00:00") = 11, month("1970-11-01") = 11
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="day.28string_date.29.2Cdayofmonth.28string_date.29"> day(string date),dayofmonth(string date) </span></h4>
</td><td> Return the day part of a date or a timestamp string: day("1970-11-01 00:00:00") = 1, day("1970-11-01") = 1
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="hour.28string_date.29"> hour(string date) </span></h4>
</td><td> Returns the hour of the timestamp: date is a string in the format of 'yyyy-MM-dd HH:mm:ss' or 'HH:mm:ss'.
<pre> Example:
&gt; SELECT hour('2009-07-30 12:58:59') FROM src LIMIT 1;
12
&gt; SELECT hour('12:58:59') FROM src LIMIT 1;
12
</pre>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="minute.28string_date.29"> minute(string date) </span></h4>
</td><td> Returns the minute of the timestamp: date is a string in the format of 'yyyy-MM-dd HH:mm:ss' or 'HH:mm:ss'.
<p>Example:
</p>
<pre>  &gt; SELECT minute('2009-07-30 12:58:59') FROM src LIMIT 1;
58
&gt; SELECT minute('12:58:59') FROM src LIMIT 1;
58
</pre>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="second.28string_date.29"> second(string date) </span></h4>
</td><td> Returns the second of the timestamp:date is a string in the format of 'yyyy-MM-dd HH:mm:ss' or 'HH:mm:ss'.
<p>Example:
</p>
<pre>  &gt; SELECT second('2009-07-30 12:58:59') FROM src LIMIT 1;
59
&gt; SELECT second('12:58:59') FROM src LIMIT 1;
59
</pre>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="weekofyear.28string_date.29"> weekofyear(string date) </span></h4>
</td><td> Returns the week of the year of the given date. A week is considered to start on a Monday and week 1 is the first week with &gt;3 days.
<p>Examples:
</p>
<pre> &gt; SELECT weekofyear('2008-02-20') FROM src LIMIT 1;
8
&gt; SELECT weekofyear('1980-12-31 12:59:59') FROM src LIMIT 1;
1
</pre>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="week.28string_date.29"> week(string date) </span></h4>
</td><td> 返回一个日期是星期几。参数的形式可以是"YYYY-MM-DD"或者"YYYYMMDD"。返回值为1~7，其中1表示星期天，2~7分别表示星期一~星期六
<p>Examples:
</p>
<pre> &gt; select week("2013-07-05");
6
&gt; select week("20130706");
7
</pre>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="commonStr.28col1.2Ccol2.2Cseparator.29"> commonStr(col1,col2,separator) </span></h4>
</td><td> Returns the common elements of col1 and col2 which separated by separator
<p>col1 and col2 and separator must be String type, they will be casted to Text, col1 and col2 is separated by separatorExample:
</p>
<pre>  &gt; SELECT commonStr('a,b,c,d','d,c',',') FROM src LIMIT 1;
c,d
&gt; SELECT commonStr(' ab,bc,ac','ac,bc',',') FROM src LIMIT 1;
bc,ac
</pre>
</td></tr>
<tr>
<td> String
</td><td>
<h4> <span class="mw-headline" id="datediff.28string_enddate.2Cstring_startdate.29"> datediff(string enddate,string startdate) </span></h4>
</td><td> Return the number of days from startdate to enddate: datediff('2009-03-01', '2009-02-27') = 2 Or Return the number of days from startdate to enddate: datediff('20090301', '20090227') = 2
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="date_add.28string_startdate.2Cint_days.29"> date_add(string startdate,int days) </span></h4>
</td><td> Add a number of days to startdate: date_add('2008-12-31', 1) = '2009-01-01' Or Add a number of days to startdate: date_add('20081231', 1) = '20090101'
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="date_sub.28string_startdate.2Cint_days.29"> date_sub(string startdate,int days) </span></h4>
</td><td> Subtract a number of days to startdate: date_sub('2008-12-31', 1) = '2008-12-30' Or Subtract a number of days to startdate: date_sub('20081231', 1) = '20081230'
</td></tr></table>
<h3> <span class="mw-headline" id=".E6.9D.A1.E4.BB.B6.E5.87.BD.E6.95.B0"> 条件函数 </span></h3>
<table border="1">

<tr>
<td> <b>Return Type</b>
</td><td> <b>Name(Signature)</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td> T
</td><td>
<h4> <span class="mw-headline" id="if.28boolean_test_Condition.2C_T_value_TRUE.2C_T_value_FALSE_or_NULL.29"> if(boolean test Condition, T value TRUE, T value FALSE or NULL) </span></h4>
</td><td> Return valueTrue when testCondition is TRUE, returns value FALSE or NULL otherwise
</td></tr>
<tr>
<td> T
</td><td>
<h4> <span class="mw-headline" id="COALESCE.28T_v1.2C_T_v2.2C_....29"> COALESCE(T v1, T v2, ...) </span></h4>
</td><td> Return the first v that is not NULL, or NULL if all v's are NULL
</td></tr>
<tr>
<td> T
</td><td>
<h4> <span class="mw-headline" id="CASE_a_WHEN_b_THEN_c_.5BWHEN_d_THEN_e.5D.2A_.5BELSE_f.5D_END"> CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END </span></h4>
</td><td> When a = b, returns c; when a = d, return e; else return f
<p>该函数的用法与decode函数一致，支持int和bigint类型的混合使用，其他类型要求保证一致性。a和c不可为null（表字段不受该限制）。该函数参数是变长的，最少3个参数，最多255个参数。
</p>
</td></tr>
<tr>
<td> T
</td><td>
<h4> <span class="mw-headline" id="CASE_WHEN_a_THEN_b_.5BWHEN_c_THEN_d.5D.2A_.5BELSE_e.5D_END"> CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END </span></h4>
</td><td> When a = TRUE, returns b; when c = TRUE, return d; else return e
<p>该函数暂时不支持int和bigint类型混合，120版本后会支持。
</p>
</td></tr></table>
<h3> <span class="mw-headline" id=".E5.AD.97.E7.AC.A6.E4.B8.B2.E5.87.BD.E6.95.B0"> 字符串函数 </span></h3>
<table border="1">

<tr>
<td> <b>Return Type</b>
</td><td> <b>Name(Signature)</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="length.28string_A.29"> length(string A) </span></h4>
</td><td> Returns the length of the string
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="reverse.28string_A.29"> reverse(string A) </span></h4>
</td><td> Returns the reversed string
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="concat.28string_A.2Cstring_B.29"> concat(string A,string B) </span></h4>
</td><td> Returns the string resulting from concatenating the strings passed in as parameters in order. e.g.
<pre>concat('foo', 'bar') results in 'foobar'. Note that this function can take any number of input strings.
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="substr.28string_A.2Cint_start.29.2Csubstring.28string_A.2C_int_start.29"> substr(string A,int start),substring(string A, int start) </span></h4>
</td><td> Returns the substring of A starting from start position till the end of string A. e.g.
<pre>substr('foobar', 4) results in 'bar' (see <a href="http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_substr" class="external autonumber" rel="nofollow">[4]</a>)
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="substr.28string_A.2Cint_start.2Cint_len.29.2Csubstring.28string_A.2C_int_start.2Cint_len.29"> substr(string A,int start,int len),substring(string A, int start,int len) </span></h4>
</td><td> Returns the substring of A starting from start position with length len. e.g.
<pre>substr('foobar', 4, 1) results in 'b' (see <a href="http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_substr" class="external autonumber" rel="nofollow">[5]</a>)
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="upper.28string_A.29.2Cucase.28string_A.29"> upper(string A),ucase(string A) </span></h4>
</td><td> Returns the string resulting from converting all characters of A to upper case. e.g.
<pre>upper('fOoBaR') results in 'FOOBAR'
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="lower.28string_A.29.2Clcase.28string_A.29"> lower(string A),lcase(string A) </span></h4>
</td><td> Returns the string resulting from converting all characters of B to lower case. e.g.
<pre>lower('fOoBaR') results in 'foobar'
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="trim.28string_A.29"> trim(string A) </span></h4>
</td><td> Returns the string resulting from trimming spaces from both ends of A. e.g.
<pre>trim(' foobar ') results in 'foobar'
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="ltrim.28string_A.29"> ltrim(string A) </span></h4>
</td><td> Returns the string resulting from trimming spaces from the beginning(left hand side) of A. e.g.
<pre>ltrim(' foobar ') results in 'foobar '
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="rtrim.28string_A.29"> rtrim(string A) </span></h4>
</td><td> Returns the string resulting from trimming spaces from the end(right hand side) of A. e.g.
<pre>rtrim(' foobar ') results in ' foobar'
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="regexp_replace.28string_A.2C_string_B.2C_string_C.29"> regexp_replace(string A, string B, string C) </span></h4>
</td><td>
<p>Returns the string resulting from replacing all substrings in B that match the Java regular expression syntax(See Java regular expressions syntax) with C e.g. regexp_replace("foobar", "oo&#124;ar", "") returns 'fb.' Note that some care is necessary in using predefined character classes: using '\s' as the second argument will match the letter s; '\\s' is necessary to match whitespace, etc. 正则表达式的用法与JAVA兼容，参见<a href="/wiki/index.php/JAVA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="JAVA正则表达式">JAVA正则表达式</a>
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="regexp_extract.28string_subject.2C_string_pattern.2C_int_intex.29"> regexp_extract(string subject, string pattern, int intex) </span></h4>
</td><td> Returns the string extracted using the pattern. e.g. regexp_extract('foothebar', 'foo(.*?)(bar)', 2) returns 'bar.' Note that some care is necessary in using predefined character classes: using '\s' as the second argument will match the letter s; '\\s' is necessary to match whitespace, etc.
<p>正则表达式的用法与JAVA兼容，参见<a href="/wiki/index.php/JAVA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="JAVA正则表达式">JAVA正则表达式</a>
</p>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="regexp_instr.28source_char.2Cpattern.5B.2Cposition_.5B.2Coccurrence.5B.2Creturn_option.5B.2Cmatch_parameter.5D.5D.5D.5D.29"> regexp_instr(source_char,pattern[,position [,occurrence[,return_option[,match_parameter]]]]) </span></h4>
</td><td> Returns the position the pattern in the source character.
<p>REGEXP_INSTR extends the functionality of the INSTR function by letting you search a string for a regular expression pattern. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the beginning or ending position of the matched substring, depending on the value of the return_option argument. If no match is found, the function returns 0. You can see the whole definition in
</p>
<pre><a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions129.htm" class="external free" rel="nofollow">http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions129.htm</a>
</pre>
<p>Example:
</p>
<pre>SELECT regexp_instr('500 Oracle Parkway, Redwood Shores, CA', '[s&#124;r&#124;p]', 3, 2, 0, 'i') FROM src LIMIT 1;
12 will be return. 
SELECT regexp_instr('500 Oracle Parkway, Redwood Shores, CA', '[s&#124;r&#124;p]', 3, 2, 1, 'i') FROM src LIMIT 1;
13 will be return
</pre>
<p>正则表达式的用法与JAVA兼容，参见<a href="/wiki/index.php/JAVA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="JAVA正则表达式">JAVA正则表达式</a>
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="parse_url.28string_urlString.2C_string_partToExtract_.5B.2C_string_keyToExtract.5D.29"> parse_url(string urlString, string partToExtract [, string keyToExtract]) </span></h4>
</td><td> Returns the specified part from the URL. Valid values for partToExtract include HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO. e.g.
<pre>parse_url('<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1'" class="external free" rel="nofollow">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1'</a>, 'HOST') returns 'facebook.com'. 
</pre>
<p>Also a value of a particular key in QUERY can be extracted by providing the key as the third argument, e.g.
</p>
<pre>parse_url('<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1'" class="external free" rel="nofollow">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1'</a>, 'QUERY', 'k1') returns 'v1'.
</pre>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="get_json_object.28string_json_string.2C_string_path.29"> get_json_object(string json_string, string path) </span></h4>
</td><td> Extract json object from a json string based on json path specified, and return json string of the extracted json object. It will return null if the input json string is invalid.
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="space.28int_n.29"> space(int n) </span></h4>
</td><td> Return a string of n spaces
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="repeat.28string_str.2C_int_n.29"> repeat(string str, int n) </span></h4>
</td><td> Repeat string n times
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="ascii.28string_str.29"> ascii(string str) </span></h4>
</td><td> Returns the numeric value of the first character of string
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="lpad.28string_str.2C_int_len.2C_string_pad.29"> lpad(string str, int len, string pad) </span></h4>
</td><td> Returns string, left-padded with pad to a length of len
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="rpad.28string_str.2C_int_len.2C_string_pad.29"> rpad(string str, int len, string pad) </span></h4>
</td><td> Returns string, right-padded with pad to a length of len
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="url_decode.28string_url_string.2C_string_encode.29"> url_decode(string url_string, string encode) </span></h4>
</td><td> Returns decode url_string
<pre>url_decode('<a href="http://tdw.boss.com/wiki/index.php?title=TDW_%E5%87%BD%E6%95%B0%E5%9C%A8%E7%BA%BF%E6%89%8B%E5%86%8C&amp;action=edit&amp;section=153','utf-8'" class="external free" rel="nofollow">http://tdw.boss.com/wiki/index.php?title=TDW_%E5%87%BD%E6%95%B0%E5%9C%A8%E7%BA%BF%E6%89%8B%E5%86%8C&amp;action=edit&amp;section=153','utf-8'</a>) returns '<a href="http://tdw.boss.com/wiki/index.php?title=TDW_函数在线手册&amp;action=edit&amp;section=153'" class="external free" rel="nofollow">http://tdw.boss.com/wiki/index.php?title=TDW_函数在线手册&amp;action=edit&amp;section=153'</a>.
</pre>
</td></tr>
<tr>
<td> array
</td><td>
<h4> <span class="mw-headline" id="split.28string_str.2C_string_regex.29"> split(string str, string regex) </span></h4>
</td><td> Splits str around occurances that match
<pre>SELECT split('ABCD:C:D:E',':')[2] returns 'D'.
</pre>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="size.28array_arr.29"> size(array arr) </span></h4>
</td><td>
<p>Returns the size of array
</p><p>SELECT size(split('a,b',',')) returns 2
</p>
</td></tr>
<tr>
<td> boolean
</td><td>
<h4> <span class="mw-headline" id="array_contains.28array_arr.2C_element.29"> array_contains(array arr, element) </span></h4>
</td><td>
<p>Returns if the element is in the array, the element must hava same type as array
</p><p>SELECT array_CONTAINS(ARRAY(0,1),0) &nbsp;returns true
</p><p>SELECT array_CONTAINS(split('0=1','='),'0') returns true
</p>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="get_main_domain.28string_url_string.29"> get_main_domain(string url_string) </span></h4>
</td><td>
<p>Returns the main domain of url_string
</p><p>SELECT get_main_domain('www.tencent.com') returns 'tencent.com'
</p>
</td></tr>
<tr>
<td> int
</td><td>
<h4> <span class="mw-headline" id="parse_xml_count.28string_xml_string.2C_string_root_label.2C_string_sub_label_....29"> parse_xml_count(string xml_string, string root_label, string sub_label ...) </span></h4>
</td><td>
<p>Returns the count of the sub_label in xml_string, the labels must start from the root label layer-by-layer
</p><p>SELECT parse_xml_count('&lt;la&gt; &lt;lb&gt; &lt;lc&gt;&lt;/lc&gt; &lt;lc&gt;&lt;/lc&gt; &lt;/lb&gt; &lt;lb&gt;&lt;/lb&gt; &lt;/la&gt;', 'la', 'lb', 'lc') returns 2
</p>
</td></tr>
<tr>
<td> array
</td><td>
<h4> <span class="mw-headline" id="parse_xml_content.28string_xml_string.2C_string_root_label.2C_string_sub_label_....29"> parse_xml_content(string xml_string, string root_label, string sub_label ...) </span></h4>
</td><td>
<p>Returns the content of the sub_label in xml_string, the labels must start from the root label layer-by-layer
</p><p>SELECT parse_xml_content('&lt;la&gt; &lt;lb&gt; &lt;lc&gt;hello&lt;/lc&gt; &lt;lc&gt;world&lt;/lc&gt; &lt;/lb&gt; &lt;lb&gt;&lt;/lb&gt; &lt;/la&gt;', 'la', 'lb', 'lc')[0] returns 'hello'
</p>
</td></tr></table>
<h3> <span class="mw-headline" id="IP.E5.87.BD.E6.95.B0"> IP函数 </span></h3>
<table border="1">

<tr>
<td> <b>Return Type</b>
</td><td> <b>Name(Signature)</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="inet_aton.28string_addr.29"> inet_aton(string addr) </span></h4>
</td><td> <div>&nbsp;returns the integer value of ip address,<br /></div><div>&nbsp;Example:&nbsp;SELECT&nbsp;inet_aton(10.10.10.10) FROM src LIMIT 1</div><div>&nbsp;return &nbsp; &nbsp;168430090</div>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="inet_ntoa.28bigint_addr.29"> inet_ntoa(bigint addr) </span></h4>
</td><td> <div>&nbsp;returns the string value of ip address,<br /></div><div>&nbsp;Example:&nbsp;SELECT&nbsp;inet_aton(168430090) FROM src LIMIT 1</div><div>&nbsp;return &nbsp; &nbsp;10.10.10.10</div>
</td></tr>
<tr>
<td> string
</td><td>
<h4> <span class="mw-headline" id="ipinfo.28string_ip_table.2Cbigint_ip.2Cint_index.29"> ipinfo(string ip_table,bigint ip,int index) </span></h4>
</td><td> <div>&nbsp;返回IP所在的IP段中的表第index列值。<br />
<p>ip表结构的约定： 1. 前二列必须为start_ip bigint, end_id bigint。 2. 表必须指定为文本非分区表且未压缩即STORED AS TEXTFILE。3.表的数据必须按start_ip,end_ip的升序保存
</p><p>定义语句如下所示： CREATE TABLE ip_table(
</p>
<pre>   start_ip BIGINT,
end_ip BIGINT
</pre>
<p>) STORED AS TEXTFILE; 如果以前的是其他格式的IP表，请使用insert语句将其插入到一张新建按前面约定格式的表。 ipinfo函数的使用： ipinfo(table_name,ip,index) table_name表示ip表的db名和表名。如:imdataoss::02_00_012。 ip表示ip地址，类型为字符串或数字。如:16777216,'10.234.234.45' index表示需要返回的第几列的值 1表示ip_start 2表示ip_end N表示table中的第n列
</p>
Example: SELECT&nbsp;ipinfo('imdataoss::02_00_012',16777216,3) FROM src LIMIT 1<br /></div><div>&nbsp;返回ip为16777216在ip表imdataoss::02_00_012中的所属的IP段的第3列值。
<p>注意事项： 由于ip表是load到内存中计算，所以这张表的大小最好不要超过100MB。 ip表里的IP分段(即start_ip和end_ip)最好不要有重叠，且是闭区间（即包括区间内数字本身）。如果ip表出现end_ip大于start_ip，或者数据格式跟定义的ip表不一致，该条数据将会被过滤。 如果ip表里的IP分段出现重复时，后面出现的IP段值会覆盖前面的IP段值。
</p>
</div>
</td></tr></table>
<h3> <span class="mw-headline" id=".E8.81.9A.E5.90.88.E5.87.BD.E6.95.B0"> 聚合函数 </span></h3>
<table border="1">

<tr>
<td> <b>Return Type</b>
</td><td> <b>Name(Signature)</b>
</td><td> <b>Description</b>
</td></tr>
<tr>
<td> bigint
</td><td>
<h4> <span class="mw-headline" id="count.28.21.29.2C_count.28expr.29.2C_count.28DISTINCT_expr.5B.2C_expr....5D.29"> count(!), count(expr), count(DISTINCT expr[, expr...]) </span></h4>
</td><td> count(*) - Returns the total number of retrieved rows, including rows containing NULL values; count(expr) - Returns the number of rows for which the supplied expression is non-NULL; count(DISTINCT expr[, expr]) - Returns the number of rows for which the supplied expression(s) are unique and non-NULL.
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="sum.28col.29.2Csum.28DISTINCT_col.29"> sum(col),sum(DISTINCT col) </span></h4>
</td><td> Returns the sum of the elements in the group or the sum of the distinct values of the column in the group
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="avg.28col.29.2Cavg.28DISTINCT_col.29"> avg(col),avg(DISTINCT col) </span></h4>
</td><td> Returns the average of the elements in the group or the average of the distinct values of the column in the group
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="min.28col.29"> min(col) </span></h4>
</td><td> Returns the minimum of the column in the group
</td></tr>
<tr>
<td> double
</td><td>
<h4> <span class="mw-headline" id="max.28col.29"> max(col) </span></h4>
</td><td> Returns the maximum value of the column in the group
</td></tr></table>
<h2> <span class="mw-headline" id=".E6.95.B0.E6.8D.AE.E6.8C.96.E6.8E.98.E4.B8.8E.E7.BB.9F.E8.AE.A1.E5.88.86.E6.9E.90.E5.87.BD.E6.95.B0"> 数据挖掘与统计分析函数 </span></h2>
<table border="1">

<tr>
<td> 返回值
</td><td> 函数名
</td><td> 说明
</td></tr>
<tr>
<td> array&lt;array&lt;string&gt;&gt;
</td><td>
<h4> <span class="mw-headline" id="sentences.28string_str.2C_string_lang.2C_string_locale.29"> sentences(string str, string lang, string locale) </span></h4>
</td><td> 将英文句子分词，输入是英文句子，输出是array，array的每个元素对应一个完整的句子。这个完整的句子的分词又在一个array中，array的元素是句子中的单词。不支持小数点和特殊符号比如$。
<p>举例：
</p>
<pre>SELECT sentences('Hello there! I am a UDF.') FROM src LIMIT 1;"
[ ["Hello", "there"], ["I", "am", "a", "UDF"] ]"
</pre>
<p>注意： 标点符号等会被忽略。如果有lang存在，则它必需符合ISO-639 l语言简写代码（例如en表示英语，fr表示法语，de表示德语）。Country如果存在，它必须是ISO-3166中定义的国家代码（如us表示美国）。目前只支持英语，法语，德语等字母表为基础的语言和国家，不支持中文分词。如果没有指定lang和country，则会使用JAVA虚拟机默认的lang和country。
</p><p>测试用例： <a href="/wiki/index.php/Udf_sentences" title="Udf sentences">Udf sentences</a>
</p>
</td></tr>
<tr>
<td> array&lt;struct&lt;string,double&gt;&gt;
</td><td>
<h3> <span class="mw-headline" id="ngrams.28array.3Carray.3Cstring.3E.3E.2C_int_n.2C_int_k.2C_int_pf.29"> ngrams(array&lt;array&lt;string&gt;&gt;, int n, int k, int pf) </span></h3>
</td><td> 估计top-k ngrams的值。也支持ngrams(expr array&lt;String&gt;,n int,k int,pf int)形式。
<p>Expr:句子分词后的数组，或者多个句子分词后的数组的数组
</p><p>n: n=1时是unigrams，n=2时是bigrams，一般n不超过5
</p><p>K:返回多少个 highest-frequency ngrames
</p><p>Pf:可选参数，使用多少内存进行计算。内存越多，计算结果约准确，但是JVM越有可能崩溃。默认值是20，表示它维护20*k ngrams，只去最高频率的ngrams。
</p><p>测试用例： <a href="/wiki/index.php/Udaf_ngrams" title="Udaf ngrams">Udaf ngrams</a>
</p>
</td></tr>
<tr>
<td> array&lt;struct&lt;string,double&gt;&gt;
</td><td>
<h3> <span class="mw-headline" id="context_ngrams.28expr_array.3CString.3E.2Ccontext_array.3Cstring1.2Cstring2.2C....3E.2Ck_int.2Cpf_int.29"> context_ngrams(expr array&lt;String&gt;,context array&lt;string1,string2,...&gt;,k int,pf int) </span></h3>
</td><td> 估计符合一定上下文的top-k ngrams。第二个参数指定上下文，使用null来做锚。也支持或context_ngrams(expr array&lt;array&lt;String&gt;&gt;,context array&lt;string1,string2,...&gt;,k int,pf int)形式。
<p>Expr：与ngrams的第一个参数含义一致。
</p><p>Context：上下文，使用null表示一个占位符。例如arra&lt;'I','love',null&gt;，会将前两个词语是I love的3-grams选出。
</p><p>K：与ngrams的K含义相同。
</p><p>Pf：与ngrams的pf含义相同。
</p><p>测试用例： <a href="/wiki/index.php/Udaf_covar_context_ngrams" title="Udaf covar context ngrams">Udaf covar context ngrams</a>
</p>
</td></tr>
<tr>
<td> double
</td><td>
<h3> <span class="mw-headline" id="covar_pop.28_dependent-expression.2C_independent-expression_.29"> covar_pop( dependent-expression, independent-expression ) </span></h3>
</td><td>
<p>返回一组数值对的总体协方差。
</p><p><b>参数</b>
</p><p>dependent-expression 受独立变量影响的变量。
</p><p>independent-expression 影响结果的变量。
</p><p><b>注释</b>
</p><p>此函数将其参数转换为 DOUBLE 类型，以双精度浮点执行计算，然后返回 DOUBLE 值作为结果。如果将该函数应用于某一空集合，则它会返回 NULL。
</p><p>dependent-expression 和 independent-expression 都是数字类型。该函数适用于排除所有 dependent-expression 或 independent-expression 之一为空的对后剩下的 dependent-expression 和 independent-expression 对的集合。然后执行以下计算：
</p>
<pre>(SUM( x * y ) - SUM( y ) * SUM( y ) / n ) / n
</pre>
<p>其中 x 表示 dependent-expression，y 表示 independent-expression。
</p><p>测试用例： <a href="/wiki/index.php/Udaf_covar_pop" title="Udaf covar pop">Udaf covar pop</a>
</p>
</td></tr>
<tr>
<td> double
</td><td>
<h3> <span class="mw-headline" id="covar_samp.28_dependent-expression.2C_independent-expression_.29"> covar_samp( dependent-expression, independent-expression ) </span></h3>
</td><td> 返回一组数值对的样本协方差。
<p><b>参数</b>
</p><p>dependent-expression 受独立变量影响的变量。
</p><p>independent-expression 影响结果的变量。
</p><p><b>注释</b>
</p><p>此函数将其参数转换为 DOUBLE 类型，以双精度浮点执行计算，然后返回 DOUBLE 值作为结果。如果将该函数应用于某一空集合，则它会返回 NULL。
</p><p>dependent-expression 和 independent-expression 都是数字类型。该函数应用于排除所有 dependent-expression 或 independent-expression 之一为空的对后剩下的 dependent-expression 和 independent-expression 对的集合。
</p><p>测试用例： <a href="/wiki/index.php/Udaf_covar_samp" title="Udaf covar samp">Udaf covar samp</a>
</p>
</td></tr>
<tr>
<td> double
</td><td>
<h3> <span class="mw-headline" id="corr.28X.2CY.29"> corr(X,Y) </span></h3>
</td><td> 返回一组数字对的相关系数
<p>此函数将其参数转换为 DOUBLE 类型，以双精度浮点执行计算，然后返回 DOUBLE 值作为结果。如果将该函数应用于某一空集合，则它会返回 NULL。x 和 y 都是数字类型。该函数应用于排除所有 x 或 y 之一为 NULL 的对后剩下的 x 和 y 对的集合。然后执行以下计算：
</p>
<pre>COVAR_POP ( x, y ) / STDDEV_POP ( x) * STDDEV_POP ( y )
</pre>
<p>如果输入是空集合，或者只有一条记录，则返回为null。 测试用例： <a href="/wiki/index.php/Udaf_corr" title="Udaf corr">Udaf corr</a>
</p>
</td></tr></table>

<!-- 
NewPP limit report
Preprocessor node count: 724/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:33-0!1!0!!zh-cn!2!edit=0 and timestamp 20141208080332 -->
